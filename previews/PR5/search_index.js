var documenterSearchIndex = {"docs":
[{"location":"Appendices/appendix/#Appendices","page":"Appendices","title":"Appendices","text":"","category":"section"},{"location":"Appendices/appendix/#Time-Syntax","page":"Appendices","title":"Time Syntax","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Functions that allow time specification use two reserved keywords or arguments to track time:","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"s: Start (begin) time\nt: Termination (end) time","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Specify each as a DateTime, Real, or String.","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Real numbers are interpreted as seconds. Special behavior is invoked when both s and t are of Type Real.\nDateTime values should follow Julia documentation\\ <https://docs.julialang.org/en/v1/stdlib/Dates/>_\nStrings have the expected format spec YYYY-MM-DDThh:mm:ss.ssssss\nFractional second is optional and accepts up to 6 decimal places (μs)\nIncomplete time Strings treat missing fields as 0.\nExample: s=\"2016-03-23T11:17:00.333\"","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"It isn't necessary to choose values so that s ≤ t. The two values are always sorted, so that t < s doesn't error.","category":"page"},{"location":"Appendices/appendix/#Time-Types-and-Behavior","page":"Appendices","title":"Time Types and Behavior","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"typeof(s) typeof(t) Behavior\nDateTime DateTime convert to String, then sort\nDateTime Real add t seconds to s, convert to String, then sort\nDateTime String convert s to String, then sort\nReal DateTime add s seconds to t, convert to String, then sort\nReal Real treat as relative (see below), convert to String, sort\nReal String add s seconds to t, convert to String, then sort\nString DateTime convert t to String, then sort\nString Real add t seconds to s, convert to String, then sort\nString String sort","category":"page"},{"location":"Appendices/appendix/#Special-Behavior-with-two-Real-arguments","page":"Appendices","title":"Special Behavior with two Real arguments","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"If s and t are both Real numbers, they're treated as seconds measured relative to the start of the current minute. This convention may seem unusual, but it greatly simplifies web requests; for example, specifying s=-1200.0, t=0.0 is a convenient shorthand for \"the last 20 minutes of data\".","category":"page"},{"location":"Appendices/appendix/#Data-Requests-Syntax","page":"Appendices","title":"Data Requests Syntax","text":"","category":"section"},{"location":"Appendices/appendix/#channel_id","page":"Appendices","title":"Channel ID Syntax","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"NN.SSSSS.LL.CC (net.sta.loc.cha, separated by periods) is the expected syntax for all web functions. The maximum field width in characters corresponds to the length of each field (e.g. 2 for network). Fields can't contain whitespace.","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"NN.SSSSS.LL.CC.T (net.sta.loc.cha.tflag) is allowed in SeedLink. T is a single-character data type flag and must be one of DECOTL: Data, Event, Calibration, blOckette, Timing, or Logs. Calibration, timing, and logs are not in the scope of SeisBase and may crash SeedLink sessions.","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"The table below specifies valid types and expected syntax for channel lists.","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Type Description Example\nString Comma-delineated list of IDs \\\"PB.B004.01.BS1, PB.B002.01.BS1\\\"\nArray{String,1} String array, one ID string per entry [\\\"PB.B004.01.BS1\\\", \\\"PB.B002.01.BS1\\\"]\nArray{String,2} String array, one set of IDs per row [\\\"PB\\\" \\\"B004\\\" \\\"01\\\" \\\"BS1\\\";\n  \\\"PB\\\" \\\"B002\\\" \\\"01\\\" \\\"BS1\\\"]","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"The expected component order is always network, station, location, channel; thus, \"UW.TDH..EHZ\" is OK, but \"UW.TDH.EHZ\" fails.","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"chanspec()","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"note: Note\nI can't find chanspec() anywhere ... maybe it's web_chanspec()?","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Type ?chanspec in Julia to print the above info. to stdout.","category":"page"},{"location":"Appendices/appendix/#Wildcards-and-Blanks","page":"Appendices","title":"Wildcards and Blanks","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Allowed wildcards are client-specific.","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"The LOC field can be left blank in any client: \"UW.ELK..EHZ\" and [\"UW\" \"ELK\" \"\" \"EHZ\"] are all valid. Blank LOC fields are set to -- in IRIS, * in FDSN, and ?? in SeedLink.\n? acts as a single-character wildcard in FDSN & SeedLink. Thus, CC.VALT..??? is valid.\n* acts as a multi-character wildcard in FDSN. Thus, CC.VALT..* and CC.VALT..??? behave identically in FDSN.\nPartial specifiers are OK, but a network and station are always required: \"UW.EL?\" is OK, \".ELK..\" fails.","category":"page"},{"location":"Appendices/appendix/#channel_config","page":"Appendices","title":"Channel Configuration Files","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"One entry per line, ASCII text, format NN.SSSSS.LL.CCC.D. Due to client-specific wildcard rules, the most versatile configuration files are those that specify each channel most completely:","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"# This only works with SeedLink\nGE.ISP..BH?.D\nNL.HGN\nMN.AQU..BH?\nMN.AQU..HH?\nUW.KMO\nCC.VALT..BH?.D\n\n# This works with FDSN and SeedLink, but not IRIS\nGE.ISP..BH?\nNL.HGN\nMN.AQU..BH?\nMN.AQU..HH?\nUW.KMO\nCC.VALT..BH?\n\n# This works with all three:\nGE.ISP..BHZ\nGE.ISP..BHN\nGE.ISP..BHE\nMN.AQU..BHZ\nMN.AQU..BHN\nMN.AQU..BHE\nMN.AQU..HHZ\nMN.AQU..HHN\nMN.AQU..HHE\nUW.KMO..EHZ\nCC.VALT..BHZ\nCC.VALT..BHN\nCC.VALT..BHE","category":"page"},{"location":"Appendices/appendix/#server","page":"Appendices","title":"Server List","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"String Source\nBGR http://eida.bgr.de\nEMSC http://www.seismicportal.eu\nETH http://eida.ethz.ch\nGEONET http://service.geonet.org.nz\nGFZ http://geofon.gfz-potsdam.de\nICGC http://ws.icgc.cat\nINGV http://webservices.ingv.it\nIPGP http://eida.ipgp.fr\nIRIS http://service.iris.edu\nISC http://isc-mirror.iris.washington.edu\nKOERI http://eida.koeri.boun.edu.tr\nLMU http://erde.geophysik.uni-muenchen.de\nNCEDC http://service.ncedc.org\nNIEP http://eida-sc3.infp.ro\nNOA http://eida.gein.noa.gr\nORFEUS http://www.orfeus-eu.org\nRESIF http://ws.resif.fr\nSCEDC http://service.scedc.caltech.edu\nTEXNET http://rtserve.beg.utexas.edu\nUSGS http://earthquake.usgs.gov\nUSP http://sismo.iag.usp.br","category":"page"},{"location":"Appendices/appendix/#seisbase_std_keyword","page":"Appendices","title":"SeisBase Standard Keywords","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"SeisBase.KW is a memory-resident structure of default values for common keywords used by package functions. KW has one substructure, SL, with keywords specific to SeedLink. These defaults can be modified, e.g., SeisBase.KW.nev=2 changes the default for nev to 2.","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"KW Default T [1]_ Meaning\ncomp 0x00 U8 compress data on write? [2]\nfmt \"miniseed\" S request data format [3]\nmag [6.0, 9.9] A{F,1} magnitude range for queries\nn_zip 100000 I compress if length(:x) > n_zip\nnd 1 I number of days per subrequest\nnev 1 I number of events returned per query\nnx_add 360000 I length increase of undersized data array\nnx_new 8640000 I number of samples for a new channel\nopts \"\" S user-specified options [4]\nprune true B call prune! after get_data?\nrad [] A{F,1} radial search region [5]\nreg [] A{F,1} rectangular search region [6]\nsi true B autofill station info on data req? [7]\nsrc \"IRIS\" S data source; type ?seis_www for list\nto 30 I read timeout for web requests (s)\nv 0 I verbosity\nw false B write requests to disk? [8]\ny false B sync data after web request?","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":".. rubric:: Table Footnotes .. [1] Types: A = Array, B = Boolean, C = Char, DT = DateTime, F = Float, I = Integer, S = String, U8 = Unsigned 8-bit integer (UInt8) .. [2] If KW.comp == 0x00, never compress data; if KW.comp == 0x01, only compress channel i if length(S.x[i]) > KW.n_zip; if comp == 0x02, always compress data. .. [3] Strings have the same names and spellings as file formats in read_data. Note that \"sac\" in a web request is aliased to \"sacbl\", i.e., binary little-endian SAC, to match the native endianness of the Julia language. .. [4] String is passed as-is, e.g. \"szsrecs=true&repo=realtime\" for FDSN. String should not begin with an ampersand. .. [5] Specify region [centerlat, centerlon, minradius, maxradius, depmin, depmax], with lat, lon, and radius in decimal degrees (°) and depth in km with + = down. Depths are only used for earthquake searches. .. [6] Specify region [latmin, latmax, lonmin, lonmax, depmin, depmax], with lat, lon in decimal degrees (°) and depth in km with + = down. Depths are only used for earthquake searches. .. [7] FDSNWS timeseries only. .. [8] If w=true, a file name is automatically generated from the request parameters, in addition to parsing data to a SeisData structure. Files are created from the raw download even if data processing fails, in contrast to getdata(... wsac=true). .. _functionlist:","category":"page"},{"location":"Appendices/appendix/#utility_func","page":"Appendices","title":"Utility Functions","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"This appendix covers utility functions that belong in no other category.","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"d2u\nu2d\nfctoresp\nregex_find\ngetbandcode\nget_seis_channels\nguess\ninst_codes\ninst_code\nls\nj2md\nmd2j\nnamestrip\nparsetimewin\nresp_a0!\nresptofc\nset_file_ver\nvalidate_units\nvucum","category":"page"},{"location":"Appendices/appendix/#SeisBase.d2u","page":"Appendices","title":"SeisBase.d2u","text":"Alias to Dates.datetime2unix\n\n\n\n\n\n","category":"function"},{"location":"Appendices/appendix/#SeisBase.u2d","page":"Appendices","title":"SeisBase.u2d","text":"Alias to Dates.unix2datetime\n\n\n\n\n\n","category":"function"},{"location":"Appendices/appendix/#SeisBase.fctoresp","page":"Appendices","title":"SeisBase.fctoresp","text":"fctoresp(f)\nfctoresp(f, c)\n\nCreate PZResp or PZResp64 instrument response from lower corner frequency f and damping constant c.  If no damping constant is supplies, assumes c = 1/sqrt(2).\n\nSee also: PZResp, PZResp64\n\n\n\n\n\n","category":"function"},{"location":"Appendices/appendix/#SeisBase.regex_find","page":"Appendices","title":"SeisBase.regex_find","text":"regex_find(path::String, r::Regex)\n\nOS-agnostic equivalent to Linux find. First argument is a path string, second is a Regex. \n\nFile strings are postprocessed using Julia's native PCRE Regex engine. By design, find_regex only returns file names.\n\n\n\n\n\n","category":"function"},{"location":"Appendices/appendix/#SeisBase.getbandcode","page":"Appendices","title":"SeisBase.getbandcode","text":"getbandcode(fs, fc=FC)\n\nGet SEED-compliant one-character band code corresponding to instrument sample rate fs and corner frequency FC. If unset, FC is assumed to be 1 Hz.\n\n\n\n\n\n","category":"function"},{"location":"Appendices/appendix/#SeisBase.get_seis_channels","page":"Appendices","title":"SeisBase.get_seis_channels","text":"get_seis_channels(S::GphysData)\n\nGet an array with the channel numbers of all seismic data channels in S.\n\nAssumes each ID in S ends with an alphanumeric three-digit channel code and that ID fields are separated by periods: for example, two channels with IDs \"XX.YYY.00.EHZ\" and \"_.YHY\" both have an instrument code of 'H'.\n\nChannel codes less than two characters long (e.g. \"Z\" in \"AA.BBB.CC.Z\") are ignored.\n\nSEED channel codes of seismic and seismoacoustic data (for which operations like detrend! and taper! are sane) include D, G, H, J, L, M, N, P, Z.\n\nSee also: inst_codes\n\n\n\n\n\n","category":"function"},{"location":"Appendices/appendix/#SeisBase.guess","page":"Appendices","title":"SeisBase.guess","text":"function guess(fname[, v=V])\n\nTry to guess the file type of file fname. Keyword v controls verbosity. Only recognizes file formats supported by SeisBase.read_data.\n\nReturns a tuple: (ftype::String, swap::Bool)\n\nftype is the file type string to pass to read_data, except in these cases:\nif ftype == \"unknown\", guess couldn't identify the file type.\nif ftype contains a comma-separated list, the file type couldn't be\nuniquely determined.\nswap determines whether or not file should be byte-swapped by read_data.\n\nGenerally swap=true for big-Endian files, with two exceptions:\n\nin SAC and mini-SEED, tests for endianness are built into the file format,\n\nso the value of swap is irrelevant.\n\nif ftype = \"unknown\", swap=nothing is possible.\n\nWarnings\n\nfalse positives are possible for file formats outside the scope of SeisBase.\nSEGY endianness isn't reliable. In theory, SEGY headers are bigendian; in\n\npractice, SEGY headers are whatever the manufacturer imagines them to be, and endianness can be little, or mixed (e.g., a common situation is little-endian file header and big-endian trace header).\n\n\n\n\n\n","category":"function"},{"location":"Appendices/appendix/#SeisBase.inst_codes","page":"Appendices","title":"SeisBase.inst_codes","text":"inst_codes(S::GphysData)\n\nGet the instrument code of each channel in S.\n\ninst_code(S::GphysData, i::Integer)\n\nGet the instrument code of channel i.\n\ninst_code(C::GphysChannel)\n\nGet the instrument code from C.id.\n\nAssumes each ID ends with an alphanumeric three-digit channel code and that ID fields are separated by periods: for example, two channels with IDs \"XX.YYY.00.EHZ\" and \"_.YHY\" each have an instrument code of 'H'.\n\nChannel codes less than two characters long (e.g. \"Z\" in \"AA.BBB.CC.Z\") are ignored.\n\nSEED channel codes of seismic and seismoacoustic data (for which operations like detrend! and taper! are sane) include D, G, H, J, L, M, N, P, Z.\n\nSEED channel codes of seismometers (for which translate_resp! and remove_resp! are sane) are H, J, L, M, N, P, Z.\n\n\n\n\n\n","category":"function"},{"location":"Appendices/appendix/#SeisBase.inst_code","page":"Appendices","title":"SeisBase.inst_code","text":"inst_code(S::GphysData, i::Integer)\ninst_code(C::GphysChannel)\n\nGet instrument codes.\n\nSee inst_codes.\n\n\n\n\n\ninst_codes(S::GphysData)\n\nGet the instrument code of each channel in S.\n\ninst_code(S::GphysData, i::Integer)\n\nGet the instrument code of channel i.\n\ninst_code(C::GphysChannel)\n\nGet the instrument code from C.id.\n\nAssumes each ID ends with an alphanumeric three-digit channel code and that ID fields are separated by periods: for example, two channels with IDs \"XX.YYY.00.EHZ\" and \"_.YHY\" each have an instrument code of 'H'.\n\nChannel codes less than two characters long (e.g. \"Z\" in \"AA.BBB.CC.Z\") are ignored.\n\nSEED channel codes of seismic and seismoacoustic data (for which operations like detrend! and taper! are sane) include D, G, H, J, L, M, N, P, Z.\n\nSEED channel codes of seismometers (for which translate_resp! and remove_resp! are sane) are H, J, L, M, N, P, Z.\n\n\n\n\n\n\n\n","category":"function"},{"location":"Appendices/appendix/#SeisBase.ls","page":"Appendices","title":"SeisBase.ls","text":"ls(str::String)\n\nSimilar functionality to Bash ls with OS-agnostic output. Accepts wildcards in paths and file names.\n\nAlways returns the full path and file name.\nPartial file name wildcards (e.g. \"ls(data/2006*.sac)) invoke glob.\nPath wildcards (e.g. ls(/data/*/*.sac)) invoke find_regex to circumvent glob limitations.\nPassing ony \"\" as a filename (e.g. \"`ls(/home/)) invokesfind_regex` to recursively search subdirectories, as in the Bash shell.\nls()\n\nReturn full path and file name of files in current working directory.\n\n\n\n\n\n","category":"function"},{"location":"Appendices/appendix/#SeisBase.j2md","page":"Appendices","title":"SeisBase.j2md","text":"m,d = j2md(y,j)\n\nConvert Julian day j of year y to month m, day d\n\n\n\n\n\n","category":"function"},{"location":"Appendices/appendix/#SeisBase.md2j","page":"Appendices","title":"SeisBase.md2j","text":"j = md2j(y, m, d)\n\nConvert month m, day d of year y to Julian day (day of year)\n\n\n\n\n\n","category":"function"},{"location":"Appendices/appendix/#SeisBase.namestrip","page":"Appendices","title":"SeisBase.namestrip","text":"namestrip(s::String, convention::String=\"File\")\n\nRemove bad characters from the :name fields of S. Specify convention as a string (default is \"File\"):\n\n\"File\" => ['<', '>', ':', '\"', '/', '\\', '|', '?', '*', '^', '$', '@', '~', '\u007f']\n\"HTML\" => ['\"', '', '&', ';', '<', '>' , '©', '\u007f']\n\"Julia\" => ['$', '\\', '\u007f']\n\"Markdown\" => ['!', '#', '(', ')', '*', '+', '-', '.', '[', '\\', ']', '_', '`', '{', '}']\n\"SEED\" => ['.', '\u007f']\n\"Strict\" => [' ', '!', '\"', '#', '$', '%', '&', ''', '(', ')', '*', '+', ',', '-', '.', '/', ':', ';', '<', '=', '>', '?', '@', '\\', '^', '{', '|', '}', '~', '\u007f']\n\n\n\n\n\n","category":"function"},{"location":"Appendices/appendix/#SeisBase.parsetimewin","page":"Appendices","title":"SeisBase.parsetimewin","text":"(str0, str1) = parsetimewin(ts1::TimeSpec, ts2::TimeSpec)\n\nConvert times s and t to strings and sorts s.t. d0 < d1.\n\ns and t can be real numbers, DateTime objects, or ASCII strings.  Expected string format is \"yyyy-mm-ddTHH:MM:SS.nnn\", e.g. 2016-03-23T11:17:00.333.\n\nSee also: TimeSpec\n\n\n\n\n\n","category":"function"},{"location":"Appendices/appendix/#SeisBase.resp_a0!","page":"Appendices","title":"SeisBase.resp_a0!","text":"resp_a0!(R::Union{PZResp, PZResp64})\n\nUpdate normalization factor R.a0 from R.z, R.p, and R.f0.\n\nresp_a0!(S::GphysData)\n\nCall resp_a0! on each response in S with typeof(S.resp[i]) ∈ [PZResp, PZResp64].\n\nSee also: PZResp, PZResp64\n\n\n\n\n\n","category":"function"},{"location":"Appendices/appendix/#SeisBase.resptofc","page":"Appendices","title":"SeisBase.resptofc","text":"resptofc(R::Union{PZResp, PZResp64}))\n\nAttempt to guess critical frequency of seismic instrument response R. Assumes broadband sensors behave roughly like geophones (i.e., as harmonic oscillators with a single lower corner frequency) at low frequencies.\n\nSee also: fctoresp, PZResp\n\n\n\n\n\n","category":"function"},{"location":"Appendices/appendix/#SeisBase.set_file_ver","page":"Appendices","title":"SeisBase.set_file_ver","text":"set_file_ver(fname, ver)\n\nSets the SeisBase file version of file fname.\n\n\n\n\n\n","category":"function"},{"location":"Appendices/appendix/#SeisBase.validate_units","page":"Appendices","title":"SeisBase.validate_units","text":"validate_units(S::GphysData)\n\nTest whether unit strings in S.units are valid under the UCUM standard.\n\nvalidate_units(C::GphysChannel)\n\nTest whether C.units is valid under the UCUM standard.\n\n\n\n\n\n","category":"function"},{"location":"Appendices/appendix/#SeisBase.vucum","page":"Appendices","title":"SeisBase.vucum","text":"vucum(str::String)\n\nTest whether str is a valid UCUM unit string.\n\n\n\n\n\n","category":"function"},{"location":"Appendices/appendix/#SeisBase-Native-Format","page":"Appendices","title":"SeisBase Native Format","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Invoking the command wseis writes SeisBase structures to a native data format in little-endian byte order. This page documents the low-level file format. Abbreviations used:","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Type Meaning C Fortran 77\nChar Unicode character wchar CHARACTER*4\nFloat32 32-bit float float REAL\nFloat64 64-bit float double REAL*8\nInt8 signed 8-bit int short INTEGER\nInt16 signed 16-bit int int INTEGER*2\nInt32 signed 32-bit int long INTEGER*4\nInt64 signed 64-bit integer long long INTEGER*8\nUInt8 unsigned 8-bit int unsigned short CHARACTER\nUInt16 unsigned 16-bit int unsigned \nUInt32 unsigned 32-bit int unsigned long \nUInt64 unsigned 64-bit int unsigned long long ","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Special instructions:","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Parentheses, \"()\", denote a custom object Type.\n\"{ (condition)\" denotes the start of a loop; (condition) is the control flow.\n\"}\" denotes the end of a loop.","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Note that String in Julia has no exact C equivalence. SeisBase writes each String in two parts: an Int64 (String length in bytes) followed by the String contents (as bytes, equivalent to UInt8). Unlike C/Fortran, there are no issues with strings that contain the null character (0x00 or x0).","category":"page"},{"location":"Appendices/appendix/#SeisBase-File","page":"Appendices","title":"SeisBase File","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Var Meaning T N\n \"SeisBase\" UInt8 6\nV SeisBase file format version Float32 1\nJ # of SeisBase objects in file UInt32 1\nC SeisBase object codes for each object UInt32 J\nB Byte indices for each object UInt64 J\n{   for i = 1:J\n (Objects) variable J\n}   \nID ID hashes UInt64 variable\nTS Start times Int64 variable\nTE End times Int64 variable\nP Parent object index in C and B variable \nbID Byte offset of ID array Int64 1\nbTS Byte offset of TS array Int64 1\nbTE Byte offset of TE array Int64 1\nbP Byte offset of P array Int64 1","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"ID, TS, and TE are the ID, data start time, and data end time of each channel in each object. P is the index of the parent object in C and B. TS and TE are measured from Unix epoch time (1970-01-01T00:00:00Z) in integer microseconds.","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Intent: when seeking data from channel i between times s and t, if hash(i) matches ID[j] and the time windows overlap, retrieve index k = P[j] from NP, seek to byte offset B[k], and read an object of type C[k] from file.","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"If an archive contains no data objects, ID, TS, TE, and P are empty; equivalently, bID == bTS.","category":"page"},{"location":"Appendices/appendix/#Simple-Object-Types","page":"Appendices","title":"Simple Object Types","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Fields of these objects are written in one of three ways: as \"plain data\" types, such as UInt8 or Float64; as arrays; or as strings.","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"In a simple object, each array is stored as follows:","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Int64 number of dimensions (e.g. 2)\nInt64 array of dimensions themselves (e.g. 2, 2)\nArray values (e.g. 0.08250153, 0.023121119, 0.6299772, 0.79595184)","category":"page"},{"location":"Appendices/appendix/#EQLoc","page":"Appendices","title":"EQLoc","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Var Type N Meaning\nlat Float64 1 latitude\nlon Float64 1 longitude\ndep Float64 1 depth\ndx Float64 1 x-error\ndy Float64 1 y-error\ndz Float64 1 z-error\ndt Float64 1 t-error (error in origin time)\nse Float64 1 standard error\nrms Float64 1 rms pick error\ngap Float64 1 azimuthal gap\ndmin Float64 1 minimum source-receiver distance in location\ndmax Float64 1 maximum source-receiver distance in location\nnst Int64 1 number of stations used to locate earthquake\nflags UInt8 1 one-bit flags for special location properties\nLd Int64 1 length of \"datum\" string in bytes\ndatum UInt8 Ld Datum string\nLt Int64 1 length of \"typ\" (event type) string in bytes\ntyp UInt8 Lt earthquake type string\nLi Int64 1 length of \"sig\" (error significance) string in bytes\nsig UInt8 Li earthquake location error significance string\nLr Int64 1 length of \"src\" (data source) string in bytes\nsrc UInt8 Lr data source string","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"flag meanings: (0x01 = true, 0x00 = false)","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"x fixed?\ny fixed?\nz fixed?\nt fixed?","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"In Julia, get the value of flag[n] with ((flags n-1) 7).","category":"page"},{"location":"Appendices/appendix/#EQMag","page":"Appendices","title":"EQMag","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Var Type N Meaning\nval Float32 1 magnitude value\ngap Float64 1 largest azimuthal gap between stations in magnitude\nnst Int64 1 number of stations used in magnitude computation\nLsc Int64 1 length of magnitude scale string\nmsc UInt8 Lsc magnitude scale string\nLr Int64 1 length of data source string\nsrc UInt8 Lr data source string","category":"page"},{"location":"Appendices/appendix/#SeisPha","page":"Appendices","title":"SeisPha","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Var Type N Meaning\nF Float64 8 amplitude, distance, incidence angle, residual,\n   ray parameter, takeoff angle, travel time, uncertainty\nC Char 2 polarity, quality","category":"page"},{"location":"Appendices/appendix/#SourceTime","page":"Appendices","title":"SourceTime","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Var Type N Meaning\nLd Int64 1 size of descriptive string in bytes\ndesc UInt8 1 descriptive string\nF Float64 3 duration, rise time, decay time","category":"page"},{"location":"Appendices/appendix/#StringVec","page":"Appendices","title":"StringVec","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"A vector of variable-length strings; its exact Type in Julia is Array{String,1}.","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":".. csv-table:: StringVec   :header: Var, Type, N, Meaning   :widths: 1, 1, 1, 8","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Var Type N Meaning\nee UInt8 1 is this string vector empty? [1]\nL Int64 1 number of strings to read\n{   i = 1:L\nnb Int64 1 length of string in bytes\nstr UInt8 nb string\n}   ","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"[1] If ee == 0x00, then no values are stored for L, nb, or str.","category":"page"},{"location":"Appendices/appendix/#Location-Types","page":"Appendices","title":"Location Types","text":"","category":"section"},{"location":"Appendices/appendix/#GenLoc","page":"Appendices","title":"GenLoc","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Var Type N Meaning\nLd Int64 1 length of datum string in bytes\ndatum UInt8 Ld datum string\nLl Int64 1 length of location vector in bytes\nloc Float64 Ll location vector","category":"page"},{"location":"Appendices/appendix/#GeoLoc","page":"Appendices","title":"GeoLoc","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Var Type N Meaning\nLd Int64 1 length of datum string in bytes\ndatum UInt8 Ld datum string\nF Float64 6 latitude, longitude, elevation,\n   depth, azimuth, incidence","category":"page"},{"location":"Appendices/appendix/#UTMLoc","page":"Appendices","title":"UTMLoc","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Var Type N Meaning\nLd Int64 1 length of datum string in bytes\ndatum UInt8 N datum string\nzone Int8 1 UTM zone number\nhemi Char 1 hemisphere\nE UInt64 1 Easting\nN UInt64 1 Northing\nF Float64 4 elevation, depth, azimuth, incidence","category":"page"},{"location":"Appendices/appendix/#XYLoc","page":"Appendices","title":"XYLoc","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Var Type N Meaning\nLd Int64 1 Length of datum string in bytes\ndatum UInt8 Ld datum string\nF Float64 8 x, y, z, azimuth, incidence, origin x, origin y, origin z","category":"page"},{"location":"Appendices/appendix/#Response-Types","page":"Appendices","title":"Response Types","text":"","category":"section"},{"location":"Appendices/appendix/#GenResp","page":"Appendices","title":"GenResp","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Var Type N Meaning\nLd Int64 1 length of descriptive string in bytes\ndesc UInt8 Ld descriptive string\nnr Int64 1 Number of rows in complex response matrix\nnc Int64 1 Number of columns in complex response matrix\nresp Complex{Float64,2} nr*nc complex response matrix","category":"page"},{"location":"Appendices/appendix/#PZResp","page":"Appendices","title":"PZResp","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Var Type N Meaning\nc Float32 1 damping constant\nnp Int64 1 number of complex poles\np Complex{Float32,1} np complex poles vector\nnz Int64 1 number of complex zeros\nz Complex{Float32,1} nz complex zeros vector","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"PZResp64 is identical to PZResp with Float64 values for c, p, z, rather than Float32.","category":"page"},{"location":"Appendices/appendix/#The-Misc-Dictionary","page":"Appendices","title":"The Misc Dictionary","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Most compound objects below contain a dictionary (Dict{String,Any}) for non-essential information in a field named misc. The tables below describe how this field is written to disk.","category":"page"},{"location":"Appendices/appendix/#Misc","page":"Appendices","title":"Misc","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":".. csv-table::   :header: Var, Type, N, Meaning   :widths: 1, 2, 1, 8","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Var Type N Meaning\nN Int64 1 number of items in dictionary [1]\nK (StringVec) 1 dictionary keys\n{   for i = 1:N\nc UInt8 1 Type code of object i\no variable 1 object i\n}   ","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"[1] If N == 0, then N is the only value present.","category":"page"},{"location":"Appendices/appendix/#Dictionary-Contents","page":"Appendices","title":"Dictionary Contents","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"These subtables describe how to read the possible data types in a Misc dictionary.","category":"page"},{"location":"Appendices/appendix/#String-Array-(c-0x81)","page":"Appendices","title":"String Array (c == 0x81)","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Var Type N Meaning\nA (StringVec) 1 string vector","category":"page"},{"location":"Appendices/appendix/#Other-Array-(c-0x80-or-c-0x81)","page":"Appendices","title":"Other Array (c == 0x80 or c > 0x81)","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Var Type N Meaning\nnd Int64 1 number of dimensions in array\ndims Int64 nd array dimensions\narr varies prod(nd) array","category":"page"},{"location":"Appendices/appendix/#String-(c-0x01)","page":"Appendices","title":"String (c == 0x01)","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Var Type N Meaning\nL Int64 1 size of string in bytes\nstr UInt8 1 string","category":"page"},{"location":"Appendices/appendix/#Bits-Type-(c-0x00-or-0x01-c-0x7f)","page":"Appendices","title":"Bits Type (c == 0x00 or 0x01 < c < 0x7f)","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Read a single value whose Type corresponds to the UInt8 Type code.","category":"page"},{"location":"Appendices/appendix/#Compound-Object-Types","page":"Appendices","title":"Compound Object Types","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Each of these objects contains at least one of the above simple object types.","category":"page"},{"location":"Appendices/appendix/#PhaseCat","page":"Appendices","title":"PhaseCat","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Var Type N Meaning\nN Int64 1 number of SeisPha objects to read  [1]\nK (StringVec) 1 dictionary keys\npha (SeisPha) N seismic phases","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"[1] If N == 0, then N is the only value present.","category":"page"},{"location":"Appendices/appendix/#EventChannel","page":"Appendices","title":"EventChannel","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"A single channel of data related to a seismic event","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Var Type N Meaning\nNi Int64 1 size of id string in bytes\nid UInt8 Ni id string\nNn Int64 1 size of name string in bytes\nname UInt8 Nn name string\nLt UInt8 1 location Type codes\nloc (Loc Type) 1 instrument position\nfs Float64 1 sampling frequency in Hz\ngain Float64 1 scalar gain\nRt UInt8 1 response Type codes\nresp (Resp Type) 1 instrument response\nNu Int64 1 size of units string in bytes\nunits UInt8 Nu units string\naz Float64 1 azimuth\nbaz Float64 1 backazimuth\ndist Float64 1 source-receiver distance\npha (PhaseCat) 1 phase catalog\nNr Int64 1 size of data source string in bytes\nsrc UInt8 Nr data source string\nmisc (Misc) 1 dictionary for non-essential information\nnotes (StringVec) 1 notes and automated logging\nNt Int64 1 length of time gaps matrix\nT Int64 2Nt time gaps matrix\nXc UInt8 1 Type code of data vector\nNx Int64 1 number of samples in data vector\nX variable NX data vector","category":"page"},{"location":"Appendices/appendix/#SeisChannel","page":"Appendices","title":"SeisChannel","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"A single channel of univariate geophysical data","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Var Type N Meaning\nNi Int64 1 size of id string in bytes\nid UInt8 Ni id string\nNn Int64 1 size of name string in bytes\nname UInt8 Nn name string\nLt UInt8 1 location Type codes\nloc (Loc Type) 1 instrument position\nfs Float64 1 sampling frequency in Hz\ngain Float64 1 scalar gain\nRt UInt8 1 response Type codes\nresp (Resp Type) 1 instrument response\nNu Int64 1 size of units string in bytes\nunits UInt8 Nu units string\nNr Int64 1 size of data source string in bytes\nsrc UInt8 Nr data source string\nmisc (Misc) 1 dictionary for non-essential information\nnotes (StringVec) 1 notes and automated logging\nNt Int64 1 length of time gaps matrix\nT Int64 2Nt time gaps matrix\nXc UInt8 1 Type code of data vector\nNx Int64 1 number of samples in data vector\nX variable NX data vector","category":"page"},{"location":"Appendices/appendix/#EventTraceData","page":"Appendices","title":"EventTraceData","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"A multichannel record of time-series data related to a seismic event.","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Var Type N Meaning\nN Int64 1 number of data channels\nLc UInt8 N location Type codes for each data channel\nRc UInt8 N response Type codes for each data channel\nXc UInt8 N data Type code for each data channel\ncmp UInt8 1 are data compressed? (0x01 = yes)\nNt Int64 N number of rows in time gaps matrix for each channel\nNx Int64 N length of data vector for each channel [1]\nid (StringVec) 1 channel ids\nname (StringVec) 1 channel names\nloc (Loc Type) N instrument positions\nfs Float64 N sampling frequencies of each channel in Hz\ngain Float64 N scalar gains of each channel\nresp (Resp Type) N instrument responses\nunits (StringVec) 1 units of each channel's data\naz Float64 N event azimuth\nbaz Float64 N backazimuths to event\ndist Float64 N source-receiver distances\npha (PhaseCat) N phase catalogs for each channel\nsrc (StringVec) 1 data source strings for each channel\nmisc (Misc) N dictionaries of non-essential information for each channel\nnotes (StringVec) N notes and automated logging for each channel\n{   for i = 1:N\nT Int64 2Nt[i] Matrix of time gaps for channel i\n}   \n{   for i = 1:N\nX Xc[i] Nx[i] Data vector i [2]\n}   ","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"[1] If cmp == 0x01, each value in Nx is the number of bytes of compressed data to read; otherwise, this is the number of samples in each channel.\n[2] If cmp == 0x01, read Nx[i] samples of type UInt8 and pass through lz4 decompression to generate data vector i; else read Nx[i] samples of the type corresponding to code Xc[i].","category":"page"},{"location":"Appendices/appendix/#SeisData","page":"Appendices","title":"SeisData","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"A record containing multiple channels of univariate geophysical data.","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Var Type N Meaning\nN Int64 1 number of data channels\nLc UInt8 N location Type codes for each data channel\nRc UInt8 N response Type codes for each data channel\nXc UInt8 N data Type code for each data channel\ncmp UInt8 1 are data compressed? (0x01 = yes)\nNt Int64 N number of rows in time gaps matrix for each channel\nNx Int64 N length of data vector for each channel [1]\nid (StringVec) 1 channel ids\nname (StringVec) 1 channel names\nloc (Loc Type) N instrument positions\nfs Float64 N sampling frequencies of each channel in Hz\ngain Float64 N scalar gains of each channel\nresp (Resp Type) N instrument responses\nunits (StringVec) 1 units of each channel's data\nsrc (StringVec) 1 data source strings for each channel\nmisc (Misc) N dictionaries of non-essential information for each channel\nnotes (StringVec) N notes and automated logging for each channel\n{   for i = 1:N\nT Int64 2Nt[i] Matrix of time gaps for channel i\n}   \n{   for i = 1:N\nX Xc[i] Nx[i] Data vector i [2]\n}   ","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"[1] If cmp == 0x01, each value in Nx is the number of bytes of compressed data to read; otherwise, this is the number of samples in each channel.\n[2] If cmp == 0x01, read Nx[i] samples of type UInt8 and pass through lz4 decompression to generate data vector i; else read Nx[i] samples of the type corresponding to code Xc[i].","category":"page"},{"location":"Appendices/appendix/#SeisHdr","page":"Appendices","title":"SeisHdr","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Var Type N Meaning\nLi Int64 1 length of event ID string\nid UInt8 Li event ID string\niv UInt8 1 intensity value\nLs Int64 1 length of intensity scale string\nisc UInt8 Ls intensity scale string\nloc (EQLoc) 1 earthquake location\nmag (EQMag) 1 earthquake magnitude\nmisc (Misc) 1 dictionary containing non-essential information\nnotes (StringVec) 1 notes and automated logging\not Int64 1 origin time [1]\nLr Int64 1 length of data source string\nsrc UInt8 Lr data source string\nLt Int64 1 length of event type string\ntyp UInt8 Lt event type string","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"[1] Measured from Unix epoch time (1970-01-01T00:00:00Z) in integer microseconds","category":"page"},{"location":"Appendices/appendix/#SeisSrc","page":"Appendices","title":"SeisSrc","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Var Type N Meaning\nLi Int64 1 length of source id string\nid UInt8 Li id string\nLe Int64 1 length of event id string\neid UInt8 Le event id string\nm0 Float64 1 scalar moment\nLm Int64 1 length of moment tensor vector\nmt Float64 Lm moment tensor vector\nLd Int64 1 length of moment tensor misfit vector\ndm Float64 Ld moment tensor misfit vector\nnp Int64 1 number of polarities\ngap Float64 1 max. azimuthal gap\npad Int64 2 dimensions of principal axes matrix\npax Float64 pad[1]*pad[2] principal axes matrix\npld Int64 2 dimensions of nodal planes matrix\nplanes Float64 pld[1]*pld[2] nodal planes matrix\nLr Int64 1 length of data source string\nsrc UInt8 1 data source string\nst (SourceTime) 1 source-time description\nmisc (Misc) 1 Dictionary containing non-essential information\nnotes (StringVec) 1 Notes and automated logging","category":"page"},{"location":"Appendices/appendix/#SeisEvent","page":"Appendices","title":"SeisEvent","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Var Type N Meaning\nhdr (SeisHdr) 1 event header\nsource (SeisSrc) 1 event source process\ndata (EventTraceData) 1 event trace data","category":"page"},{"location":"Appendices/appendix/#Data-Type-Codes","page":"Appendices","title":"Data Type Codes","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Each Type code is written to disk as a UInt8, with the important exception of SeisBase custom object Type codes (which use UInt32).","category":"page"},{"location":"Appendices/appendix/#loc_type_code","page":"Appendices","title":"Loc Type Codes","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"UInt8 Type\n0x00 GenLoc\n0x01 GeoLoc\n0x02 UTMLoc\n0x03 XYLoc","category":"page"},{"location":"Appendices/appendix/#resp_type_code","page":"Appendices","title":"Resp Type Codes","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"UInt8 Type\n0x00 GenResp\n0x01 PZResp\n0x02 PZResp64","category":"page"},{"location":"Appendices/appendix/#other_type_code","page":"Appendices","title":"Other Type Codes","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Only the Types below are faithfully preserved in write/read of a :misc field dictionary; other Types are not written to file and can cause wseis to throw errors.","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Type UInt8 Type UInt8\nChar 0x00 Array{Char,N} 0x80\nString 0x01 Array{String,N} 0x81\nUInt8 0x10 Array{UInt8,N} 0x90\nUInt16 0x11 Array{UInt16,N} 0x91\nUInt32 0x12 Array{UInt32,N} 0x92\nUInt64 0x13 Array{UInt64,N} 0x93\nUInt128 0x14 Array{UInt128,N} 0x94\nInt8 0x20 Array{Int8,N} 0xa0\nInt16 0x21 Array{Int16,N} 0xa1\nInt32 0x22 Array{Int32,N} 0xa2\nInt64 0x23 Array{Int64,N} 0xa3\nInt128 0x24 Array{Int128,N} 0xa4\nFloat16 0x30 Array{Float16,N} 0xb0\nFloat32 0x31 Array{Float32,N} 0xb1\nFloat64 0x32 Array{Float64,N} 0xb2\nComplex{UInt8} 0x50 Array{Complex{UInt8},N} 0xd0\nComplex{UInt16} 0x51 Array{Complex{UInt16},N} 0xd1\nComplex{UInt32} 0x52 Array{Complex{UInt32},N} 0xd2\nComplex{UInt64} 0x53 Array{Complex{UInt64},N} 0xd3\nComplex{UInt128} 0x54 Array{Complex{UInt128},N} 0xd4\nComplex{Int8} 0x60 Array{Complex{Int8},N} 0xe0\nComplex{Int16} 0x61 Array{Complex{Int16},N} 0xe1\nComplex{Int32} 0x62 Array{Complex{Int32},N} 0xe2\nComplex{Int64} 0x63 Array{Complex{Int64},N} 0xe3\nComplex{Int128} 0x64 Array{Complex{Int128},N} 0xe4\nComplex{Float16} 0x70 Array{Complex{Float16},N} 0xf0\nComplex{Float32} 0x71 Array{Complex{Float32},N} 0xf1\nComplex{Float64} 0x72 Array{Complex{Float64},N} 0xf2","category":"page"},{"location":"Appendices/appendix/#seisbase_object_code","page":"Appendices","title":"SeisBase Object Type codes","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"UInt32 Code Object Type\n0x20474330 EventChannel\n0x20474331 SeisChannel\n0x20474430 EventTraceData\n0x20474431 SeisData\n0x20495030 GenLoc\n0x20495031 GeoLoc\n0x20495032 UTMLoc\n0x20495033 XYLoc\n0x20495230 GenResp\n0x20495231 PZResp64\n0x20495232 PZResp\n0x20504330 PhaseCat\n0x20534530 SeisEvent\n0x20534830 SeisHdr\n0x20535030 SeisPha\n0x20535330 SeisSrc\n0x20535430 SourceTime\n0x45514c30 EQLoc\n0x45514d30 EQMag","category":"page"},{"location":"Appendices/appendix/#File-Format-Version-History","page":"Appendices","title":"File Format Version History","text":"","category":"section"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"File format versions <0.50 are no longer supported; please email us if you need to read in very old data.","category":"page"},{"location":"Appendices/appendix/","page":"Appendices","title":"Appendices","text":"Version Date Change\n0.53 2019-09-11 removed :i, :o from CoeffResp\n  added :i, :o to MultiStageResp\n0.52 2019-09-03 added CoeffResp, MultiStageResp\n0.51 2019-08-01 added :f0 to PZResp, PZResp64\n0.50 2019-06-05 all custom Types can now use write() directly\n  rewrote how :misc is stored\n  Type codes for :misc changed\n  deprecated BigFloat/BigInt support in :misc\n  :n is no longer stored as a UInt32\n  :x compression no longer automatic\n  :x compression changed from Blosc to lz4","category":"page"},{"location":"Intro/intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"Intro/intro/","page":"Introduction","title":"Introduction","text":"SeisBase is a framework for working with univariate geophysical data on 64-bit systems. SeisBase is designed around three basic principles:","category":"page"},{"location":"Intro/intro/","page":"Introduction","title":"Introduction","text":"Ease of use: one shouldn't need a PhD to understand command syntax.\nFluidity: working with data shouldn't feel clumsy.\nPerformance: speed and efficient memory usage matter.","category":"page"},{"location":"Intro/intro/","page":"Introduction","title":"Introduction","text":"The project is home to an expanding set of web clients, file format readers, and analysis utilities.","category":"page"},{"location":"Intro/intro/#Overview","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"Intro/intro/","page":"Introduction","title":"Introduction","text":"SeisBase stores data in minimalist containers that track the bare necessities for analysis. New data are easily added with basic operators like +. Unwanted channels can be removed just as easily. Data can be written to a number of file formats.","category":"page"},{"location":"Intro/intro/#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"Intro/intro/","page":"Introduction","title":"Introduction","text":"From the Julia prompt: press ] to enter the Pkg environment, then type","category":"page"},{"location":"Intro/intro/","page":"Introduction","title":"Introduction","text":"pkg> add SeisBase; build; precompile","category":"page"},{"location":"Intro/intro/","page":"Introduction","title":"Introduction","text":"Dependencies should install automatically. To verify that everything works correctly, type","category":"page"},{"location":"Intro/intro/","page":"Introduction","title":"Introduction","text":"pkg> test SeisBase","category":"page"},{"location":"Intro/intro/","page":"Introduction","title":"Introduction","text":"and allow 10-20 minutes for tests to complete. Exit the Pkg environment by pressing Backspace or Control + C.","category":"page"},{"location":"Intro/intro/#Getting-Started","page":"Introduction","title":"Getting Started","text":"","category":"section"},{"location":"Intro/intro/","page":"Introduction","title":"Introduction","text":"At the Julia prompt, type","category":"page"},{"location":"Intro/intro/","page":"Introduction","title":"Introduction","text":"using SeisBase","category":"page"},{"location":"Intro/intro/","page":"Introduction","title":"Introduction","text":"You'll need to repeat this step whenever you restart Julia, as with any command-line interpreter (CLI) language.","category":"page"},{"location":"Intro/intro/#Learning-SeisBase","page":"Introduction","title":"Learning SeisBase","text":"","category":"section"},{"location":"Intro/intro/","page":"Introduction","title":"Introduction","text":"An interactive tutorial using Jupyter notebooks in a web browser can be accessed from the Julia prompt with these commands:","category":"page"},{"location":"Intro/intro/","page":"Introduction","title":"Introduction","text":"julia> p = pathof(SeisBase);\n\njulia> d = dirname(realpath(p));\n\njulia> cd(d);\n\njulia> include(\"../tutorial/install.jl\");","category":"page"},{"location":"Intro/intro/","page":"Introduction","title":"Introduction","text":"SeisBase also has an online tutorial guide<tutorial>, intended as a gentle introduction for people less familiar with the Julia language. The two are intentionally redundant; Jupyter isn't compatible with all systems and browsers.","category":"page"},{"location":"Intro/intro/","page":"Introduction","title":"Introduction","text":"For a faster start, skip to any of these topics:","category":"page"},{"location":"Intro/intro/","page":"Introduction","title":"Introduction","text":"Working with Data<wwd>: learn how to manage data using SeisBase\nReading Data<readdata>: learn how to read data from file\nWeb Requests<getdata>: learn how to download data","category":"page"},{"location":"Intro/intro/#Updating","page":"Introduction","title":"Updating","text":"","category":"section"},{"location":"Intro/intro/","page":"Introduction","title":"Introduction","text":"From the Julia prompt: press ] to enter the Pkg environment, then type update. Once package updates finish, restart Julia to use them.","category":"page"},{"location":"Submodules/quake/#Quake","page":"Quake","title":"Quake","text":"","category":"section"},{"location":"Submodules/quake/","page":"Quake","title":"Quake","text":"The Quake submodule was introduced in SeisBase v0.3.0 to isolate handling of discrete earthquake events from handling of continuous geophysical data. While the channel data are similar, fully describing an earthquake event requires many additional Types (objects) and more information (fields) in channel descriptors.","category":"page"},{"location":"Submodules/quake/#Types","page":"Quake","title":"Types","text":"","category":"section"},{"location":"Submodules/quake/","page":"Quake","title":"Quake","text":"SeisBase.Quake.EQMag\nSeisBase.Quake.EQLoc\nSeisBase.Quake.EventChannel\nSeisBase.Quake.EventTraceData\nSeisBase.Quake.SeisEvent\nSeisBase.Quake.SeisHdr\nSeisBase.Quake.SeisPha\nSeisBase.Quake.SeisSrc\nSeisBase.Quake.SourceTime","category":"page"},{"location":"Submodules/quake/#SeisBase.Quake.EQMag","page":"Quake","title":"SeisBase.Quake.EQMag","text":"EQMag\n\nEarthquake magnitude container object\n\nField Type Meaning\nval Float32 numeric magnitude value (note: Float32!)\nscale String magnitude scale (freeform)\ngap Float64 azimuthal gap (°)\nnst Int64 number of stations used in magnitude calculation\nsrc String magnitude source\n\n\n\n\n\n","category":"type"},{"location":"Submodules/quake/#SeisBase.Quake.EQLoc","page":"Quake","title":"SeisBase.Quake.EQLoc","text":"EQLoc\n\nQuakeML-compliant earthquake location\n\nField Type Meaning SeisBase conventions/behavior\nlat Float64 latitude °N = +\nlon Float64 longitude °E = +\ndep Float64 depth km; down = +\ndx Float64 x error uses units of data source (typically km)\ndy Float64 y error uses units of data source (typically km)\ndz Float64 z error uses units of data source (typically km)\ndt Float64 ot error uses units of data source (typically s)\nse Float64 std error uses units of data source (typically s)\nrms Float64 rms pick err uses units of data source (typically s)\ngap Float64 azimuthal gap uses units of data source (typically °)\ndmin Float64 min sta dist uses units of data source (typically km)\ndmax Float64 max sta dist uses units of data source (typically km)\nnst Int64 # of stations \nflags UInt8 boolean flags access flag[n] with >>(<<(flags,n-1),7)\ndatum String geog. datum \ntyp String location type freeform (e.g. \"centroid\", \"hypocenter\")\nsig String significance freeform (e.g. \"95%\", \"2σ\")\n  / confidence \nsrc String source freeform (e.g. \"HYPOELLIPSE\", \"HypoDD\")\n\nflags (0x01 = true, 0x00 = false)\n\nx fixed?\ny fixed?\nz fixed?\nt fixed?\n\n\n\n\n\n","category":"type"},{"location":"Submodules/quake/#SeisBase.Quake.EventChannel","page":"Quake","title":"SeisBase.Quake.EventChannel","text":"EventChannel\n\nA single channel of trace data (digital seismograms) associated with a discrete event (earthquake).\n\nSee EventTraceData\n\n\n\n\n\n","category":"type"},{"location":"Submodules/quake/#SeisBase.Quake.EventTraceData","page":"Quake","title":"SeisBase.Quake.EventTraceData","text":"EventTraceData\n\nA custom structure designed to describe trace data (digital seismograms) associated with a discrete event (earthquake).\n\nEventChannel\n\nA single channel of trace data (digital seismograms) associated with a discrete event (earthquake).\n\nFields: EventTraceData, EventChannel, SeisEvent.data\n\nField Description\n:n Number of channels [1]\n:id Channel id. Uses NET.STA.LOC.CHA format when possible\n:name Freeform channel name\n:loc Location (position) vector; any subtype of InstrumentPosition\n:fs Sampling frequency in Hz; fs=0.0 for irregularly-sampled data.\n:gain Scalar gain\n:resp Instrument response; any subtype of InstrumentResponse\n:units String describing data units. UCUM standards are assumed.\n:az Source azimuth\n:baz Backazimuth to source\n:dist Source-receiver distance\n:pha Seismic phase catalog\n:src Freeform string describing data source.\n:misc Dictionary for non-critical information.\n:notes Timestamped notes; includes automatically-logged information.\n:t Matrix of time gaps in integer μs, formatted [Sample# Length]\n:x Time-series data\n\nNot present in EventChannel objects.\n\nSee also: PhaseCat, SeisPha, SeisData\n\n\n\n\n\n","category":"type"},{"location":"Submodules/quake/#SeisBase.Quake.SeisEvent","page":"Quake","title":"SeisBase.Quake.SeisEvent","text":"SeisEvent\n\nA structure for discrete seismic events, comprising three structures:\n\n:hdr, a SeisHdr for the event descriptor\n:source, a SeisSrc for descrition of the seismic source process\n:data, an EventTraceData structure for channel data, including phases\n\nSee also: SeisHdr, SeisSrc, EventTraceData\n\n\n\n\n\n","category":"type"},{"location":"Submodules/quake/#SeisBase.Quake.SeisHdr","page":"Quake","title":"SeisBase.Quake.SeisHdr","text":"SeisHdr: header information for seismic events\n\nS = SeisHdr()\n\nInitialize an empty SeisHdr object. Fields can be initialized at creation with keywords, e.g., SeisHdr(ot=DateTime(\"2012-01-03T03:49:45\"), int=(0x02, \"MMI\")).\n\nField Default Type Meaning\nid \"\" String Event ID\nint (0x00, \"\") Tuple (Intensity, Intensity Scale)\nloc () EQLoc Hypocenter data\nmag () EQMag Magnitude data\nmisc () Dict{String,Any}() Non-essential info\not (unix epoch) DateTime Origin time\nnotes [] Array{String,1} Timestamped notes, logging\nsrc \"\" String Data source (URL/filename)\ntyp \"\" String Event type\n\nSee also: EQLoc, EQMag\n\n\n\n\n\n","category":"type"},{"location":"Submodules/quake/#SeisBase.Quake.SeisPha","page":"Quake","title":"SeisBase.Quake.SeisPha","text":"SeisPha()\n\nIRIS-style seismic phase and pick container\n\nField Type Meaning SeisBase conventions/behavior\namp Float64 amplitude uses units of data source\nd Float64 distance no unit conversion; can be m, km, or °\nia Float64 incidence angle uses units of data source\nres Float64 pick residual \nrp Float64 ray parameter \nta Float64 takeoff angle \ntt Float64 travel time \nunc Float64 uncertainty \npol Char polarity \nqual Char pick quality not (re)calculated\n\n\n\n\n\n","category":"type"},{"location":"Submodules/quake/#SeisBase.Quake.SeisSrc","page":"Quake","title":"SeisBase.Quake.SeisSrc","text":"SeisSrc: container for descriptions of a seismic source process\n\nS = SeisSrc()\n\nInitialize an empty SeisSrc object. Fields can be initialized at creation with keywords; for example, S = SeisSrc(m0 = 1.6e22).\n\nField Type Meaning\nid String source process ID\neid String event ID (note, generally :id != :eid)\nm0 Float64 scalar seismic moment\nmt Array{Float64,1} seismic moment tensor\ndm Array{Float64,1} seismic moment tensor misfit\nnpol Int64 number of polarities in focal mechanism\ngap Float64 max azimuthal gap in focal mechanism\npax Array{Float64,2} principal axes\nplanes Array{Float64,2} nodal planes\nsrc String data source string (filename or URL)\nst SourceTime source-time subfield\nmisc Dict{String,Any} dictionary of non-essential information\nnotes Array{String,1} notes and automated logging\n\nSee also: EQLoc, EQMag, SourceTime\n\n\n\n\n\n","category":"type"},{"location":"Submodules/quake/#SeisBase.Quake.SourceTime","page":"Quake","title":"SeisBase.Quake.SourceTime","text":"SourceTime()\n\nQuakeML-compliant seismic source-time parameterization.\n\nField Type Meaning SeisBase conventions/behavior\ndesc String description \ndur Float64 duration \nrise Float64 rise time \ndecay Float64 decay time \n\n\n\n\n\n","category":"type"},{"location":"Submodules/quake/#Web-Queries","page":"Quake","title":"Web Queries","text":"","category":"section"},{"location":"Submodules/quake/","page":"Quake","title":"Quake","text":"Keyword descriptions for web queries appear at the end of this section.","category":"page"},{"location":"Submodules/quake/","page":"Quake","title":"Quake","text":"SeisBase.Quake.FDSNevq\nSeisBase.Quake.FDSNevt\nSeisBase.Quake.get_pha!","category":"page"},{"location":"Submodules/quake/#SeisBase.Quake.FDSNevq","page":"Quake","title":"SeisBase.Quake.FDSNevq","text":"(H,R) = FDSNevq(ot)\n\nMulti-server query for the events with the closest origin time to ot. Returns an Array{SeisHdr,1} in H with event headers and an Array{SeisSrc,1} in R in H with corresponding source process info.\n\nKeywords\n\nKW Default T [1] Meaning\nevw [600., 600.] Float64 search window in seconds [2]\nmag [6.0, 9.9] Float64 search magitude range\nnev 0 Integer events per query [3]\nrad [] Float64 radius search\nreg [] Float64 geographic search region\nsrc [4] \"IRIS\" String data source; ?seis_www lists\nto 30 Int64 timeout (s) for web requests\nv 0 Integer verbosity\n\nArray{T, 1} for evw, mag, rad, reg; T for others\nsearch range is always ot-|evw[1]| ≤ t ≤ ot+|evw[2]|\nif nev=0, all matches are returned.\nIn an event query, keyword src can be a comma-delineated list, like \"IRIS, INGV, NCEDC\".\n\nNotes\n\nSpecify ot as a string formatted YYYY-MM-DDThh:mm:ss in UTC (e.g. \"2001-02-08T18:54:32\").\nIncomplete string queries are read to the nearest fully-specified time constraint; thus, FDSNevq(\"2001-02-08\")    returns the nearest event to 2001-02-08T00:00:00.\nIf no event is found in the specified search window, FDSNevq exits with an error.\nFor FDSNevq, keyword src can be a comma-delineated list of sources, provided each has a value in ?seis_www;    for example, src=\"IRIS, INGV, NCEDC\" is valid.\n\nSee also: SeisBase.KW, ?seis_www\n\n\n\n\n\n","category":"function"},{"location":"Submodules/quake/#SeisBase.Quake.FDSNevt","page":"Quake","title":"SeisBase.Quake.FDSNevt","text":"FDSNevt(ot::String, chans::String)\n\nGet header and trace data for the event closest to origin time ot on channels chans. Returns a SeisEvent structure.\n\nKeywords\n\nKW Default T [1] Meaning\nevw [600., 600.] Float64 search window in seconds [2]\nfmt \"miniseed\" String request data format\nlen 120.0 Float64 desired trace length [s]\nmag [6.0, 9.9] Float64 search magitude range\nmodel \"iasp91\" String velocity model for phases\nnd 1 Real number of days per subrequest\nopts \"\" String user-specified options[3]\npha \"P\" String phases to get  [4]\nrad [] Float64 radius search\nreg [] Float64 geographic search region\nsrc \"IRIS\" String data source; ?seis_www lists\nto 30 Int64 timeout (s) for web requests\nv 0 Integer verbosity\nw false Bool write requests to disk?\n\nKW is Array{T, 1} for evw, mag, rad, reg, type T for others\nSearch range is always ot-|evw[1]| ≤ t ≤ ot+|evw[2]|\nFormat like an http request string, e.g. \"szsrecs=true&repo=realtime\" for FDSN. String shouldn't begin with an ampersand.\nComma-separated String, like \"P, pP\"; use \"ttall\" for all phases\n\nNotes\n\nSpecify ot as a string formatted YYYY-MM-DDThh:mm:ss in UTC (e.g. \"2001-02-08T18:54:32\").\nIncomplete string queries are read to the nearest fully-specified time constraint; thus, FDSNevq(\"2001-02-08\")    returns the nearest event to 2001-02-08T00:00:00.\nIf no event is found in the specified search window, FDSNevt exits with an error.\nUnlike FDSNevq, number of events cannot be specified and src must be a single source String in ?seis_www.\n\nSee also: distaz!, FDSNevq, FDSNsta\n\n\n\n\n\n","category":"function"},{"location":"Submodules/quake/#SeisBase.Quake.get_pha!","page":"Quake","title":"SeisBase.Quake.get_pha!","text":"get_pha!(Ev::SeisEvent[, keywords])\n\nCommand-line interface to IRIS online travel time calculator, which calls TauP [1-2]. Returns a matrix of strings.\n\nKeywords:\n\npha: comma-separated String of phases (\"P, S, SP\")\nmodel: velocity model (\"iasp91\")\nto: timeout in seconds\nv: verbosity\n\nReferences\n\nTauP manual: http://www.seis.sc.edu/downloads/TauP/taup.pdf\nCrotwell, H. P., Owens, T. J., & Ritsema, J. (1999). The TauP Toolkit:\n\nFlexible seismic travel-time and ray-path utilities, SRL 70(2), 154-160.\n\n\n\n\n\n","category":"function"},{"location":"Submodules/quake/#Web-Query-Keywords","page":"Quake","title":"Web Query Keywords","text":"","category":"section"},{"location":"Submodules/quake/","page":"Quake","title":"Quake","text":"KW Default T [1] Meaning\nevw [600.0, 600.0] A{F,1} search window in seconds [2]\nfmt \"miniseed\" S request data format\nlen 120.0 I desired trace length [s]\nmag [6.0, 9.9] A{F,1} magnitude range for queries\nmodel \"iasp91\" S Earth velocity model for phase times\nnd 1 I number of days per subrequest\nnev 0 I number of events returned per query [3]\nopts \"\" S user-specified options [4]\npha \"P\" S phases to get [5]\nrad [] A{F,1} radial search region [6]\nreg [] A{F,1} rectangular search region [7]\nsrc \"IRIS\" S data source; type ?seis_www for list\nto 30 I read timeout for web requests [s]\nv 0 I verbosity\nw false B write requests to disk? [8]","category":"page"},{"location":"Submodules/quake/","page":"Quake","title":"Quake","text":"Table Footnotes","category":"page"},{"location":"Submodules/quake/","page":"Quake","title":"Quake","text":"Types: A = Array, B = Boolean, C = Char, DT = DateTime, F = Float, I = Integer, S = String, U8 = Unsigned 8-bit integer (UInt8)\nsearch range is always ot-evw1  t  ot+evw2\nnev=0 returns all events in the query\nString is passed as-is, e.g. \"szsrecs=true&repo=realtime\" for FDSN. String should not begin with an ampersand.\nComma-separated String, like \"P, pP\"; use \"ttall\" for all phases\nSpecify region [centerlat, centerlon, minradius, maxradius, depmin, depmax], with lat, lon, and radius in decimal degrees (°) and depth in km with + = down. Depths are only used for earthquake searches.\nSpecify region [latmin, latmax, lonmin, lonmax, depmin, depmax], with lat, lon in decimal degrees (°) and depth in km with + = down. Depths are only used for earthquake searches.\nIf w=true, a file name is automatically generated from the request parameters, in addition to parsing data to a SeisData structure. Files are created from the raw download even if data processing fails, in contrast to get_data(... wsac=true).","category":"page"},{"location":"Submodules/quake/#Example","page":"Quake","title":"Example","text":"","category":"section"},{"location":"Submodules/quake/","page":"Quake","title":"Quake","text":"Get seismic and strainmeter records for the P-wave of the Tohoku-Oki great earthquake on two borehole stations and write to native SeisData format:","category":"page"},{"location":"Submodules/quake/","page":"Quake","title":"Quake","text":"S = FDSNevt(\"201103110547\", \"PB.B004..EH?,PB.B004..BS?,PB.B001..BS?,PB.B001..EH?\")\nwseis(\"201103110547_evt.seis\", S)","category":"page"},{"location":"Submodules/quake/#Utility-Functions","page":"Quake","title":"Utility Functions","text":"","category":"section"},{"location":"Submodules/quake/","page":"Quake","title":"Quake","text":"SeisBase.Quake.distaz!\nSeisBase.Quake.gcdist\nSeisBase.Quake.show_phases\nSeisBase.Quake.fill_sac_evh!","category":"page"},{"location":"Submodules/quake/#SeisBase.Quake.distaz!","page":"Quake","title":"SeisBase.Quake.distaz!","text":"distaz!(Ev::SeisEvent)\n\nCompute Δ, Θ by the Haversine formula. \n\nUpdates Ev.data with distance, azimuth, and backazimuth for each channel, written to Ev.data.dist, Ev.data.az, and Ev.data.baz, respectively.\n\n\n\n\n\n","category":"function"},{"location":"Submodules/quake/#SeisBase.Quake.gcdist","page":"Quake","title":"SeisBase.Quake.gcdist","text":"G = gcdist(src, rec)\n\nCompute great circle distance, azimuth, and backazimuth from single source s with coordinates [s_lat, s_lon] to receivers r with coordinates [r_lat r_lon].\n\nFor a single source, pass src as a Float64 vector of the form [s_lat, s_lon]; gcdist will return an Array{Float64,2} of the form\n\n[Δ₁   θ₁   β₁\n Δ₂   θ₂   β₂\n ⋮    ⋮    ⋮\n Δn   θn   βn]\n\nfor receivers 1:n.\n\nFor multiple sources, pass src as an Array{Float64,2} with each row containing one (lat, lon) pair. This returns a three-dimensional matrix where each two-dimensional slice takes the form\n\n  [Δᵢ₁   θᵢ₁   βᵢ₁\n   ⋮     ⋮     ⋮\n   Δᵢn   θᵢn   βᵢn]\n\nfor source i at receivers 1:n.\n\n\n\n\n\n","category":"function"},{"location":"Submodules/quake/#SeisBase.Quake.show_phases","page":"Quake","title":"SeisBase.Quake.show_phases","text":"show_phases(io::IO, PC::PhaseCat)\n\nFormatted display of seismic phases in dictionary P.\n\n\n\n\n\n","category":"function"},{"location":"Submodules/quake/#SeisBase.Quake.fill_sac_evh!","page":"Quake","title":"SeisBase.Quake.fill_sac_evh!","text":"fill_sac_evh!(Ev::SeisEvent, fname::String; k=i)\n\nFill (overwrite) values in Ev.hdr with data from SAC file fname. Keyword k=i specifies the reference channel i from which the absolute origin time Ev.hdr.ot is set. Potentially affects header fields :id, :loc (subfields .lat, .lon, .dep), and :ot.\n\n\n\n\n\n","category":"function"},{"location":"Submodules/quake/#Reading-Earthquake-Data-Files","page":"Quake","title":"Reading Earthquake Data Files","text":"","category":"section"},{"location":"Submodules/quake/","page":"Quake","title":"Quake","text":"SeisBase.Quake.read_quake","category":"page"},{"location":"Submodules/quake/#SeisBase.read_quake","page":"Quake","title":"SeisBase.read_quake","text":"Ev = read_quake(fmt, file)\n\nRead data in file format fmt from file into SeisEvent object Ev.\n\nFormats: suds, qml, uw\nKeywords: full, v\n\nNote: because earthquake data are usually discrete, self-contained files, no \"in-place\" version of read_quake exists,  and  read_quake doesn't support wildcards in the file string.\n\nSupported File Formats\n\nFile Format String Notes\nPC-SUDS suds \nQuakeML qml, quakeml only reads first event from file\nUW uw \n\nSee also: read_data, get_data, read_meta, UW.readuwevt\n\n\n\n\n\n","category":"function"},{"location":"Submodules/quake/#QuakeML","page":"Quake","title":"QuakeML","text":"","category":"section"},{"location":"Submodules/quake/","page":"Quake","title":"Quake","text":"read_qml\nwrite_qml","category":"page"},{"location":"Downloading/seedlink/#seedlink","page":"SeedLink","title":"SeedLink","text":"","category":"section"},{"location":"Downloading/seedlink/","page":"SeedLink","title":"SeedLink","text":"SeedLink is a TCP/IP-based data transmission protocol that allows near-real-time access to data from thousands of geophysical monitoring instruments. See data keywords list and channel id syntax for options.","category":"page"},{"location":"Downloading/seedlink/","page":"SeedLink","title":"SeedLink","text":"seedlink\nseedlink!","category":"page"},{"location":"Downloading/seedlink/#SeisBase.seedlink","page":"SeedLink","title":"SeisBase.seedlink","text":"seedlink(mode, chans)\n\nSee seedlink! for details.\n\n\n\n\n\n","category":"function"},{"location":"Downloading/seedlink/#SeisBase.seedlink!","page":"SeedLink","title":"SeisBase.seedlink!","text":"seedlink!(S, mode, chans)\nS = seedlink(mode, chans)\n\nBegin acquiring seedlink data to SeisData structure S using mode mode. New channels are added to S automatically based on chans. Connections are added to S.c. When finished, close connection manually with close(S.c[n]) where n is connection #.\n\nThis function is fully described in the official documentation at https://SeisBase.readthedocs.io/ in subsection SeedLink.\n\nKeywords: gap, kai, port, refresh, s, t, u, v, w, xonerr\n\nSee also: get_data!\n\n\n\n\n\n","category":"function"},{"location":"Downloading/seedlink/","page":"SeedLink","title":"SeedLink","text":"Initiate a SeedLink session in DATA mode to feed data from channels chans with selection patterns patts to SeisData structure S. A handle to a TCP connection is appended to S.c. Data are periodically parsed until the connection is closed. One SeisData object can support multiple connections, provided that each connection's streams feed unique channels.","category":"page"},{"location":"Downloading/seedlink/","page":"SeedLink","title":"SeedLink","text":"mode SeedLink mode (\"DATA\", \"FETCH\", or \"TIME\"; case-sensitive).","category":"page"},{"location":"Downloading/seedlink/","page":"SeedLink","title":"SeedLink","text":"chans Channel specification can use any of the following options:","category":"page"},{"location":"Downloading/seedlink/","page":"SeedLink","title":"SeedLink","text":"A comma-separated String where each pattern follows the syntax NET.STA.LOC.CHA.DFLAG, e.g. UW.TDH..EHZ.D. Use \"?\" to match any single character.\nAn Array{String,1} with one pattern per entry, following the above syntax.\nThe name of a configuration text file, with one channel pattern per line; see Channel Configuration File syntax.","category":"page"},{"location":"Downloading/seedlink/","page":"SeedLink","title":"SeedLink","text":"patts Data selection patterns. See official SeedLink documentation; syntax is identical.","category":"page"},{"location":"Downloading/seedlink/#Keywords","page":"SeedLink","title":"Keywords","text":"","category":"section"},{"location":"Downloading/seedlink/","page":"SeedLink","title":"SeedLink","text":"Shared Keywords","category":"page"},{"location":"Downloading/seedlink/","page":"SeedLink","title":"SeedLink","text":"v, w","category":"page"},{"location":"Downloading/seedlink/","page":"SeedLink","title":"SeedLink","text":"SeedLink Keywords","category":"page"},{"location":"Downloading/seedlink/","page":"SeedLink","title":"SeedLink","text":"kw def type meaning\ngap 3600 R a stream with no data in >gap seconds is considered offline\nkai 600 R keepalive interval (s)\nport 18000 I port number\nrefresh 20 R base refresh interval (s) [1]\nseq \"\" S Starting sequence hex value, like \"5BE37A\"\nu \"rtserve.iris.washington.edu\" S base SeedLink service URL, no \"http://\"\nx_on_err true Bool exit on error?","category":"page"},{"location":"Downloading/seedlink/","page":"SeedLink","title":"SeedLink","text":"Table Footnotes","category":"page"},{"location":"Downloading/seedlink/","page":"SeedLink","title":"SeedLink","text":"[1] This value is a base value; a small amount is added to this number by each new SeedLink session to minimize the risk of congestion","category":"page"},{"location":"Downloading/seedlink/","page":"SeedLink","title":"SeedLink","text":"Change these with SeisBase.KW.SL.[key] = value, e.g., SeisBase.KW.SL.refresh = 30.","category":"page"},{"location":"Downloading/seedlink/#Special-Behavior","page":"SeedLink","title":"Special Behavior","text":"","category":"section"},{"location":"Downloading/seedlink/","page":"SeedLink","title":"SeedLink","text":"SeedLink follows unusual rules for wild cards in sta and patts:  a. * is not a valid SeedLink wild card.  b. The LOC and CHA fields can be left blank in sta to select all locations and channels.\nDO NOT feed one data channel from multiple SeedLink connections. This leads to TCP congestion on your computer, which can have severe consequences:  a. A channel fed by multiple SeedLink connections will have many small segments, all out of order. merge! might fix this if caught quickly, but with hundreds of disjoint segments, expect memory and CPU issues.  b. Your SeedLink connection will probably reset.  c. Julia may freeze, requiring kill -9. To the best of our knowledge Julia has no special handling to mitigate TCP congestion.  d. Your data may be corrupted, including disk writes from w=true.","category":"page"},{"location":"Downloading/seedlink/#Special-Methods","page":"SeedLink","title":"Special Methods","text":"","category":"section"},{"location":"Downloading/seedlink/","page":"SeedLink","title":"SeedLink","text":"close(S.c[i]) ends SeedLink connection i.\n!deleteat(S.c, i) removes a handle to closed SeedLink connection i.","category":"page"},{"location":"Downloading/seedlink/#SeedLink-Utilities","page":"SeedLink","title":"SeedLink Utilities","text":"","category":"section"},{"location":"Downloading/seedlink/","page":"SeedLink","title":"SeedLink","text":"sl_info\nhas_sta\nhas_stream","category":"page"},{"location":"Downloading/seedlink/#SeisBase.sl_info","page":"SeedLink","title":"SeisBase.sl_info","text":"info_xml = sl_info(level=LEVEL::String; u=URL::String, port=PORT::Integer)\n\nRetrieve XML output of SeedLink command \"INFO level\" from server URL:PORT. Returns formatted XML. level must be one of \"ID\", \"CAPABILITIES\", \"STATIONS\", \"STREAMS\", \"GAPS\", \"CONNECTIONS\", \"ALL\".\n\n\n\n\n\n","category":"function"},{"location":"Downloading/seedlink/#SeisBase.has_sta","page":"SeedLink","title":"SeisBase.has_sta","text":"has_sta(sta[, u=url, port=N])\n\nCheck that streams exist at url for stations sta, formatted NET.STA. Use \"?\" to match any single character. Returns true for stations that exist. sta can also be the name of a valid config file or a 1d string array.\n\nReturns a BitArray with one value per entry in sta.\n\nSeedLink keywords: gap, port\n\n\n\n\n\n","category":"function"},{"location":"Downloading/seedlink/#SeisBase.has_stream","page":"SeedLink","title":"SeisBase.has_stream","text":"has_stream(cha[, u=url, port=N, gap=G)\n\nCheck that streams with recent data exist at url u for channel spec cha, formatted NET.STA.LOC.CHA.DFLAG, e.g. \"UW.TDH..EHZ.D, CC.HOOD..BH?.E\". Use \"?\" to match any single character. Returns true for streams with recent data.\n\ncha can also be the name of a valid config file.\n\nhas_stream(sta::Array{String,1}, sel::Array{String,1}, u::String, port=N::Int, gap=G::Real)\n\nIf two arrays are passed to has_stream, the first should be formatted as SeedLink STATION patterns (formated \"SSSSS NN\", e.g. [\"TDH UW\", \"VALT CC\"]); the second be an array of SeedLink selector patterns (formatted LLCCC.D, e.g. [\"??EHZ.D\", \"??BH?.?\"]).\n\nSeedLink keywords: gap, port\n\n\n\n\n\n","category":"function"},{"location":"Submodules/submodules/#Submodules","page":"Submodules","title":"Submodules","text":"","category":"section"},{"location":"Submodules/submodules/","page":"Submodules","title":"Submodules","text":"Name Purpose\nASCII ASCII file formats (includes GeoCSV, SLIST, and variants)\nFastIO Replacement low-level I/O functions to avoid thread locking\nQuake Earthquake seismology\nRandSeis Generate SeisBase structures with quasi-random entries\nSEED Standard for the Exchange of Earthquake Data (SEED) file format\nSUDS Seismic Unified Data System (SUDS) file format\nSeisHDF Dedicated support for seismic HDF5 subformats\nUW University of Washington data format","category":"page"},{"location":"Submodules/submodules/#Using-Submodules","page":"Submodules","title":"Using Submodules","text":"","category":"section"},{"location":"Submodules/submodules/","page":"Submodules","title":"Submodules","text":"At the Julia prompt, type using SeisBase.NNNN where NNNN is the submodule name; for example, using SeisBase.Quake loads the Quake submodule.","category":"page"},{"location":"Submodules/submodules/#RandSeis","page":"Submodules","title":"RandSeis","text":"","category":"section"},{"location":"Submodules/submodules/","page":"Submodules","title":"Submodules","text":"This submodule is used to quickly generate SeisBase objects with quasi-random field contents. Access it with \"using SeisBase.RandSeis\"","category":"page"},{"location":"Submodules/submodules/","page":"Submodules","title":"Submodules","text":"The following are true of all random data objects generated by the RandSeis module:","category":"page"},{"location":"Submodules/submodules/","page":"Submodules","title":"Submodules","text":"Channels have SEED-compliant IDs, sampling frequencies, and data types.\nRandom junk fills :notes and :misc.\nSampling frequency (:fs) is chosen from a set of common values.\nChannel data are randomly generated.\nTime gaps are automatically inserted into regularly-sampled data.","category":"page"},{"location":"Submodules/submodules/","page":"Submodules","title":"Submodules","text":"SeisBase.RandSeis.randPhaseCat\nSeisBase.RandSeis.randSeisChannel\nSeisBase.RandSeis.randSeisData\nSeisBase.RandSeis.randSeisEvent\nSeisBase.RandSeis.randSeisHdr\nSeisBase.RandSeis.randSeisSrc","category":"page"},{"location":"Submodules/submodules/#SeisBase.RandSeis.randPhaseCat","page":"Submodules","title":"SeisBase.RandSeis.randPhaseCat","text":"randPhaseCat()\n\nGenerate a random seismic phase catalog suitable for testing EventChannel, EventTraceData, and SeisEvent objects.\n\n\n\n\n\n","category":"function"},{"location":"Submodules/submodules/#SeisBase.RandSeis.randSeisChannel","page":"Submodules","title":"SeisBase.RandSeis.randSeisChannel","text":"randSeisChannel()\n\nGenerate a random channel of geophysical time-series data as a SeisChannel.\n\nKeywords\n\nKW Default Type Meaning\ns false Bool force channel to have seismic data?\nc false Bool force channel to have irregular data?\nnx 0 Int64 number of samples in channel [1]\nfs_min 0.0 Float64 channels will have fs ≥ fs_min\nfc 0.0 Float64 rolloff frequency [2]\n\nif nx ≤ 0, the number of samples is determined randomly\nspecifing fc with c=false returns a geophone instrument response\n\nSee also: randSeisData, fctoresp\n\n\n\n\n\n","category":"function"},{"location":"Submodules/submodules/#SeisBase.RandSeis.randSeisData","page":"Submodules","title":"SeisBase.RandSeis.randSeisData","text":"randSeisData()\n\nGenerate 8 to 24 channels of random seismic data as a SeisData object.\n\nrandSeisData(N)\n\nGenerate N channels of random seismic data as a SeisData object.\n\nKeywords\n\nKW Default Type Meaning\ns 0.6 Float64 chance each channel is seismic data\nc 0.2 Float64 chance each channel is irregular (fs=0)\nnx 0 Int64 number of samples in each channel\nfs_min 0.0 Float64 regular channels have fs ≥ fs_min\na0 false Bool recalculate :resp constants?\n\nBehavior\n\nIf nx ≤ 0, the number of samples is determined randomly for each channel\n100*s is the minimum percentage of channels with guaranteed seismic data\n100*c is the maximum percentage of channels with irregularly-sampled data\ns takes precedence over c; they are not renormalized. Thus, for example:\nrandSeisData(12, c=1.0, s=1.0) works like randSeisData(12, c=0.0, s=1.0)\nrandSeisData(c=1.0) works like randSeisData(s=0.0)\nFor N channels, s*N is rounded up; c*N is rounded down. Thus:\nrandSeisData(10, c=0.28) and randSeisData(10, c=0.2) are equivalent\nrandSeisData(10, s=0.28) and randSeisData(10, s=0.3) are equivalent\nBy default, :resp.a0 = 1.0 for all channels; a0=true calls resp_a0!(S)\n:resp.p and :resp.z are random; a0=true isn't guaranteed to work\n\nSee also: randSeisChannel, resp_a0!\n\n\n\n\n\n","category":"function"},{"location":"Submodules/submodules/#SeisBase.RandSeis.randSeisEvent","page":"Submodules","title":"SeisBase.RandSeis.randSeisEvent","text":"randSeisEvent([, c=0.2, s=0.6])\n\nGenerate a SeisEvent structure filled with random header and channel data.\n\n100*c is the percentage of :data channels after the first with irregularly-sampled data (fs = 0.0)\n100*s is the percentage of :data channels after the first with guaranteed seismic data.\n\nSee also: randSeisChannel, randSeisData, randSeisHdr, randSeisSrc\n\n\n\n\n\n","category":"function"},{"location":"Submodules/submodules/#SeisBase.RandSeis.randSeisHdr","page":"Submodules","title":"SeisBase.RandSeis.randSeisHdr","text":"randSeisHdr()\n\nGenerate a SeisHdr structure filled with random values.\n\n\n\n\n\n","category":"function"},{"location":"Submodules/submodules/#SeisBase.RandSeis.randSeisSrc","page":"Submodules","title":"SeisBase.RandSeis.randSeisSrc","text":"randSeisSrc()\n\nGenerate a SeisSrc structure filled with random values.\n\n\n\n\n\n","category":"function"},{"location":"Submodules/submodules/#SEED","page":"Submodules","title":"SEED","text":"","category":"section"},{"location":"Submodules/submodules/","page":"Submodules","title":"Submodules","text":"Submodule for the Standard for the Exchange of Earthquake Data (SEED) file format; includes additional functionality.","category":"page"},{"location":"Submodules/submodules/","page":"Submodules","title":"Submodules","text":"SeisBase.SEED.dataless_support\nmseed_support\nseed_support","category":"page"},{"location":"Submodules/submodules/#Scanning-SEED-Volumes","page":"Submodules","title":"Scanning SEED Volumes","text":"","category":"section"},{"location":"Submodules/submodules/","page":"Submodules","title":"Submodules","text":"SeisBase.SEED.scan_seed","category":"page"},{"location":"Submodules/submodules/#SeisBase.SEED.scan_seed","page":"Submodules","title":"SeisBase.SEED.scan_seed","text":"soh = scan_seed(fname::String[, KWs])\n\nScan seed file fname and report properties in human-readable string array soh.\n\nGeneral Keywords\n\nquiet (Bool): true to only return compact summary strings (no stdout)\nmemmap (Bool): true to use memory mapping\nv (Integer): v > 0 increases scan verbosity\n\nOutput Keywords\n\nThese are all Booleans; false excludes from scan.\n\nnpts: Number of samples per channel (default: true)\nngaps: Number of time gaps per channel (default: true)\nnfs: Number of unique fs values per channel (default: true)\nseg_times: Exact gap times (default: false)\nfs_times: Exact times of fs changes (default: false)\n\nNote that seg_times and fs_times dump verbose per-channel tabulation to stdout.\n\nUsers are encouraged to submit feature request or issues if there's a need to scan for other changes within a SEED volume.\n\nInteraction with Online Requests\n\nscan_seed cannot interact directly with online SEED requests. As a workaround, do get_data( w=true)  to dump the raw request directly to disk, then scan the file(s) created.\n\ncaution: Caution\nRarely, the number of gaps reported is off-by-one from read_data.\n\n\n\n\n\n","category":"function"},{"location":"Submodules/submodules/#UW","page":"Submodules","title":"UW","text":"","category":"section"},{"location":"Submodules/submodules/","page":"Submodules","title":"Submodules","text":"The UW submodule extends functionality for the University of Washington (UW) file format(s).","category":"page"},{"location":"Submodules/submodules/","page":"Submodules","title":"Submodules","text":"The UW data format was created in the 1970s by the Pacific Northwest Seismic Network (PNSN), USA, for event archival. It remained in use through the 1990s. A UW event is described by a pickfile and a corresponding data file, whose filenames were identical except for the last character. The data file is self-contained; the pick file is not required to read raw trace data. However, station locations were stored in an external text file.","category":"page"},{"location":"Submodules/submodules/","page":"Submodules","title":"Submodules","text":"Only UW-2 data files are supported by SeisBase. We have only seen UW-1 data files in Exabyte tapes from the 1980s.","category":"page"},{"location":"Submodules/submodules/","page":"Submodules","title":"Submodules","text":"SeisBase.UW.uwpf","category":"page"},{"location":"Submodules/submodules/#SeisBase.UW.uwpf","page":"Submodules","title":"SeisBase.UW.uwpf","text":"H, R = uwpf(pf[, v])\n\nRead UW-format seismic pick file pf into SeisHdr object H, with seismic source description (focal mechanism) returned in SeisSrc object R.\n\nuwpf!(W, pf[, v::Integer=KW.v])\n\nRead UW-format seismic pick info from pickfile f into SeisEvent object W. Overwrites W.source and W.hdr with pickfile information. Keyword v controls verbosity.\n\ncaution: Caution\nReader has no safety check to guarantee that pf is from the same event.\n\n\n\n\n\n","category":"function"},{"location":"Intro/working_with_data/#working_with_data","page":"Working with data","title":"Working with Data","text":"","category":"section"},{"location":"Intro/working_with_data/","page":"Working with data","title":"Working with data","text":"This section is a tutorial for tracking and managing SeisBase data.","category":"page"},{"location":"Intro/working_with_data/#Creating-Data-Containers","page":"Working with data","title":"Creating Data Containers","text":"","category":"section"},{"location":"Intro/working_with_data/","page":"Working with data","title":"Working with data","text":"Create a new, empty object using any of the following commands:","category":"page"},{"location":"Intro/working_with_data/","page":"Working with data","title":"Working with data","text":"Object Purpose\nSeisChannel() A single channel of univariate (usually time-series) data\nSeisData() Multichannel univariate (usually time-series) data\nSeisHdr() Header structure for discrete seismic events\nSeisEvent() Discrete seismic events; includes SeisHdr and SeisData objects","category":"page"},{"location":"Intro/working_with_data/#Acquiring-Data","page":"Working with data","title":"Acquiring Data","text":"","category":"section"},{"location":"Intro/working_with_data/","page":"Working with data","title":"Working with data","text":"Read files with read_data<readdata>\nMake web requets with get_data<getdata>\nInitiate real-time streaming sessions to SeisData objects with seedlink<seedlink-section>","category":"page"},{"location":"Intro/working_with_data/#Keeping-Track","page":"Working with data","title":"Keeping Track","text":"","category":"section"},{"location":"Intro/working_with_data/","page":"Working with data","title":"Working with data","text":"A number of auxiliary functions exist to keep track of channels:","category":"page"},{"location":"Intro/working_with_data/","page":"Working with data","title":"Working with data","text":"namestrip","category":"page"},{"location":"Intro/working_with_data/","page":"Working with data","title":"Working with data","text":"findchan\nfindid","category":"page"},{"location":"Intro/working_with_data/#SeisBase.findchan","page":"Working with data","title":"SeisBase.findchan","text":"findchan(id::String, S::GphysData)\n\nGet all channel indices i in S with id ∈ S.id[i]\n\nCan do partial id matches, e.g. findchan(S, \"UW.\") returns indices to all channels whose IDs begin with \"UW.\".\n\n\n\n\n\n","category":"function"},{"location":"Intro/working_with_data/#SeisBase.findid","page":"Working with data","title":"SeisBase.findid","text":"findid(id::String, S::GphysData)\nfindid(S::GphysData, id::String)\n\nGet the index of the first channel in S where id .== S.id is true. Returns 0 for failure.\n\nfindid(S::GphysData, T::GphysData)\n\nGet index corresponding to the first channel in T that matches each ID in S; equivalent to [findid(id,T) for id in S.id].\n\nfindid(C::SeisChannel, S::SeisData)\nfindid(S::SeisData, C::SeisChannel)\n\nGet the index to the first channel c in S where S.id[c]==C.id.\n\n\n\n\n\n","category":"function"},{"location":"Intro/working_with_data/","page":"Working with data","title":"Working with data","text":"Convention Characters Removed:sup:¹\n\"File\" \"$*/:<>?@\\^|~DEL\n\"HTML\" \"&';<>©DEL\n\"Julia\" $\\DEL\n\"Markdown\" !#()*+-.[\\]_`{}\n\"SEED\" .DEL\n\"Strict\" !\"#$%&'()*+,-./:;<=>?@[\\]^`{|}~DEL","category":"page"},{"location":"Intro/working_with_data/","page":"Working with data","title":"Working with data","text":"¹ DEL here is \\x7f (ASCII/Unicode U+007f).","category":"page"},{"location":"Intro/working_with_data/","page":"Working with data","title":"Working with data","text":"timestamp\ntrack_off!\ntrack_on!","category":"page"},{"location":"Intro/working_with_data/#SeisBase.timestamp","page":"Working with data","title":"SeisBase.timestamp","text":"timestamp()\ntimestamp(t::DateTime)\ntimestamp(t::Real)\ntimestamp(t::String)\n\nReturn current time formatted YYYY-mm-ddTHH:MM:SS.\n\n\n\n\n\n","category":"function"},{"location":"Intro/working_with_data/#SeisBase.track_off!","page":"Working with data","title":"SeisBase.track_off!","text":"u = track_off!(S::SeisData)\n\nTurn off tracking in S and return a boolean vector of which channels have been added or altered significantly.\n\n\n\n\n\n","category":"function"},{"location":"Intro/working_with_data/#SeisBase.track_on!","page":"Working with data","title":"SeisBase.track_on!","text":"track_on!(S::SeisData)\n\nTrack changes to S.id, changes to channel structure of S, and the sizes of data vectors in S.x. Does not track data processing operations to any channel i unless length(S.x[i]) changes for channel i.\n\nWarning: If you have or suspect gapped data in any channel, do not use ungap! while tracking is active.\n\n\n\n\n\n","category":"function"},{"location":"Intro/working_with_data/#Source-Logging","page":"Working with data","title":"Source Logging","text":"","category":"section"},{"location":"Intro/working_with_data/","page":"Working with data","title":"Working with data","text":"The :src field records the last data source used to populate each channel; usually a file name or URL.","category":"page"},{"location":"Intro/working_with_data/","page":"Working with data","title":"Working with data","text":"When a data source is added to a channel, including the first time data are added, it's also recorded in the :notes field. Use show_src(S, i) to print all data sources for channel S[i] to stdout (see below for details).","category":"page"},{"location":"Intro/working_with_data/#Channel-Maintenance","page":"Working with data","title":"Channel Maintenance","text":"","category":"section"},{"location":"Intro/working_with_data/","page":"Working with data","title":"Working with data","text":"A few functions exist specifically to simplify data maintenance:","category":"page"},{"location":"Intro/working_with_data/","page":"Working with data","title":"Working with data","text":"prune!\npull","category":"page"},{"location":"Intro/working_with_data/#SeisBase.prune!","page":"Working with data","title":"SeisBase.prune!","text":"prune!(S::SeisData)\n\nDelete all channels from S that have no data (i.e. S.x is empty or non-existent).\n\n\n\n\n\n","category":"function"},{"location":"Intro/working_with_data/#SeisBase.pull","page":"Working with data","title":"SeisBase.pull","text":"T = pull(S::SeisData, id::String)\n\nExtract the first channel with id = id from S and return it as a new SeisChannel structure. The corresponding channel in S is deleted.\n\nT = pull(S::SeisData, i::Union{Integer, UnitRange, Array{In64,1}}\n\nExtract channel i from S as a new SeisChannel struct, deleting it from S.\n\n\n\n\n\n","category":"function"},{"location":"Intro/working_with_data/#Taking-Notes","page":"Working with data","title":"Taking Notes","text":"","category":"section"},{"location":"Intro/working_with_data/","page":"Working with data","title":"Working with data","text":"Functions that add and process data note these operations in the :notes field of each object affected. One can also add custom notes with the note! command:","category":"page"},{"location":"Intro/working_with_data/","page":"Working with data","title":"Working with data","text":"note!\nclear_notes!","category":"page"},{"location":"Intro/working_with_data/#SeisBase.note!","page":"Working with data","title":"SeisBase.note!","text":"note!(S::SeisData, i::Int64, s::String)\n\nAppend s with a timestamp to the :notes field of channel number i of S.\n\nnote!(S::SeisData, id::String, s::String)\n\nAs above for the first channel in S whose id is an exact match to id.\n\nnote!(S::SeisData, s::String)\n\nAppend s to S.notes and time stamp. If txt contains a channel name or ID, only the channel mentioned is annotated; otherwise, all channels are annotated.\n\nSee also: clear_notes!, show_processing, show_src, show_writes\n\n\n\n\n\n","category":"function"},{"location":"Intro/working_with_data/#SeisBase.clear_notes!","page":"Working with data","title":"SeisBase.clear_notes!","text":"clear_notes!(S::GphysData)\n\nClear all notes from S and leaves a note about this.\n\nclear_notes!(S::SeisData, i::Int64, s::String)\n\nClear all notes from channel i of S and leaves a note about this.\n\nclear_notes!(S::SeisData, id::String, s::String)\n\nAs above for the first channel in S whose id is an exact match to id.\n\nSee also: note!, show_processing, show_src\n\n\n\n\n\n","category":"function"},{"location":"Intro/working_with_data/#Checking-Your-Work","page":"Working with data","title":"Checking Your Work","text":"","category":"section"},{"location":"Intro/working_with_data/","page":"Working with data","title":"Working with data","text":"If you need to check what's been done to a channel, or the sources present in the channel data, these commands are helpful:","category":"page"},{"location":"Intro/working_with_data/","page":"Working with data","title":"Working with data","text":"show_processing\nshow_src\nshow_writes","category":"page"},{"location":"Intro/working_with_data/#SeisBase.show_processing","page":"Working with data","title":"SeisBase.show_processing","text":"show_processing(S::GphysData)\nshow_processing(S::GphysData, i::Int64)\nshow_processing(C::GphysChannel)\n\nTabulate and print all processing steps in :notes to stdout in human-readable format.\n\nSee also: show_src, show_writes, note!, clear_notes!\n\n\n\n\n\n","category":"function"},{"location":"Intro/working_with_data/#SeisBase.show_src","page":"Working with data","title":"SeisBase.show_src","text":"show_src(S::GphysData)\nshow_src(S::GphysData, i::Int64)\nshow_src(C::GphysChannel)\n\nTabulate and print all data sources logged in :notes to stdout in human-readable format.\n\nSee also: show_processing, show_writes, note!, clear_notes!\n\n\n\n\n\n","category":"function"},{"location":"Intro/working_with_data/#SeisBase.show_writes","page":"Working with data","title":"SeisBase.show_writes","text":"show_writes(S::GphysData)\nshow_writes(S::GphysData, i::Int64)\nshow_writes(C::GphysChannel)\n\nTabulate and print all data writes logged in :notes to stdout in human-readable format.\n\nSee also: show_processing, show_src, note!, clear_notes!\n\n\n\n\n\n","category":"function"},{"location":"Intro/getting_help/#Getting-Help","page":"Getting Help","title":"Getting Help","text":"","category":"section"},{"location":"Intro/getting_help/","page":"Getting Help","title":"Getting Help","text":"In addition to the Juypter notebooks and online tutorial guide, other sources of help are available:","category":"page"},{"location":"Intro/getting_help/","page":"Getting Help","title":"Getting Help","text":"Examples\nTests\nCommand-Line Help","category":"page"},{"location":"Intro/getting_help/#gettinghelp_examples","page":"Getting Help","title":"Examples","text":"","category":"section"},{"location":"Intro/getting_help/","page":"Getting Help","title":"Getting Help","text":"Several worked examples exist throughout these documents, in addition to examples.jl and the interactive tutorial.","category":"page"},{"location":"Intro/getting_help/","page":"Getting Help","title":"Getting Help","text":"Invoke the command-prompt examples with the following command sequence:","category":"page"},{"location":"Intro/getting_help/","page":"Getting Help","title":"Getting Help","text":"p = pathof(SeisBase)\nd = dirname(realpath(p))\ncd(d)\ninclude(\"../test/examples.jl\")","category":"page"},{"location":"Intro/getting_help/#gettinghelp_tests","page":"Getting Help","title":"Tests","text":"","category":"section"},{"location":"Intro/getting_help/","page":"Getting Help","title":"Getting Help","text":"The commands in tests/ can be used as templates; to install test data and run all tests, execute these commands:","category":"page"},{"location":"Intro/getting_help/","page":"Getting Help","title":"Getting Help","text":"using Pkg\nPkg.test(\"SeisBase\")      # lunch break recommended. Tests can take 20 minutes.\n                        # 99.5% code coverage wasn't an accident...\np = pathof(SeisBase)\ncd(realpath(dirname(p) * \"/../test/\"))","category":"page"},{"location":"Intro/getting_help/#gettinghelp_clhelp","page":"Getting Help","title":"Command-Line Help","text":"","category":"section"},{"location":"Intro/getting_help/","page":"Getting Help","title":"Getting Help","text":"A great deal of additional help functions are available at the Julia command prompt. All SeisBase functions and structures have their own docstrings. For example, typing ?SeisData at the Julia prompt produces the following:","category":"page"},{"location":"Intro/getting_help/","page":"Getting Help","title":"Getting Help","text":"SeisData","category":"page"},{"location":"Intro/getting_help/#SeisBase.SeisData","page":"Getting Help","title":"SeisBase.SeisData","text":"SeisData\n\nA custom structure designed to contain the minimum necessary information for processing univariate geophysical data.\n\nSeisChannel\n\nA single channel designed to contain the minimum necessary information for processing univariate geophysical data.\n\nFields\n\nField Description\n:n Number of channels [1]\n:c TCP connections feeding data to this object [1]\n:id Channel id. Uses NET.STA.LOC.CHA format when possible\n:name Freeform channel name\n:loc Location (position) vector; any subtype of InstrumentPosition\n:fs Sampling frequency in Hz; fs=0.0 for irregularly-sampled data.\n:gain Scalar gain\n:resp Instrument response; any subtype of InstrumentResponse\n:units String describing data units. UCUM standards are assumed.\n:src Freeform string describing data source.\n:misc Dictionary for non-critical information.\n:notes Timestamped notes; includes automatically-logged information.\n:t Matrix of time gaps in integer μs, formatted [Sample# Length]\n:x Time-series data\n\nNot present in SeisChannel objects.\n\nSee also: InstrumentPosition, PZResp\n\n\n\n\n\n","category":"type"},{"location":"Intro/getting_help/#Dedicated-Help-Functions","page":"Getting Help","title":"Dedicated Help Functions","text":"","category":"section"},{"location":"Intro/getting_help/","page":"Getting Help","title":"Getting Help","text":"These functions take no arguments and dump information to stdout.","category":"page"},{"location":"Intro/getting_help/#Submodule-SEED","page":"Getting Help","title":"Submodule SEED","text":"","category":"section"},{"location":"Intro/getting_help/","page":"Getting Help","title":"Getting Help","text":"SeisBase.SEED.dataless_support\nmseed_support\nSeisBase.SEED.resp_wont_read\nseed_support","category":"page"},{"location":"Intro/getting_help/#SeisBase.SEED.dataless_support","page":"Getting Help","title":"SeisBase.SEED.dataless_support","text":"dataless_support()\n\nOutput lists of supported blockettes in dataless SEED to stdout.\n\n\n\n\n\n","category":"function"},{"location":"Intro/getting_help/#SeisBase.SEED.mseed_support","page":"Getting Help","title":"SeisBase.SEED.mseed_support","text":"mseed_support()\n\nOutput lists of supported blockettes in mini-SEED to stdout.\n\n\n\n\n\n","category":"function"},{"location":"Intro/getting_help/#SeisBase.SEED.resp_wont_read","page":"Getting Help","title":"SeisBase.SEED.resp_wont_read","text":"resp_wont_read()\n\nOutput \"hall of shame\" of known examples of broken RESP to stdout.\n\n\n\n\n\n","category":"function"},{"location":"Intro/getting_help/#SeisBase.SEED.seed_support","page":"Getting Help","title":"SeisBase.SEED.seed_support","text":"seed_support()\n\nOutput full information on SEED support to stdout.\n\n\n\n\n\n","category":"function"},{"location":"Intro/getting_help/#Submodule-SUDS","page":"Getting Help","title":"Submodule SUDS","text":"","category":"section"},{"location":"Intro/getting_help/","page":"Getting Help","title":"Getting Help","text":"SeisBase.SUDS.suds_support","category":"page"},{"location":"Intro/getting_help/#SeisBase.SUDS.suds_support","page":"Getting Help","title":"SeisBase.SUDS.suds_support","text":"suds_support()\n\nDump info to STDOUT on support for each SUDS structure type.\n\nGreen structures are fully supported and read into memory.\nYellow structures can be dumped to stdout by invoking read_data(\"suds\", ...) with high verbosity (v=2).\nRed structures are unsupported and have not been seen in available test data.\n\n\n\n\n\n","category":"function"},{"location":"Intro/getting_help/#Formats-Guide","page":"Getting Help","title":"Formats Guide","text":"","category":"section"},{"location":"Intro/getting_help/","page":"Getting Help","title":"Getting Help","text":"formats is a constant static dictionary with descriptive entries of each data format. Access the list of formats with sort(keys(formats)). Then try a command like formats[\"slist\"] for detailed info. on the slist format.","category":"page"},{"location":"Intro/getting_help/#Help-Only-Functions","page":"Getting Help","title":"Help-Only Functions","text":"","category":"section"},{"location":"Intro/getting_help/","page":"Getting Help","title":"Getting Help","text":"These functions contain help docstrings but execute nothing. They exist to answer common questions.","category":"page"},{"location":"Intro/getting_help/","page":"Getting Help","title":"Getting Help","text":"web_chanspec","category":"page"},{"location":"Intro/getting_help/#SeisBase.web_chanspec","page":"Getting Help","title":"SeisBase.web_chanspec","text":"web_chanspec\n\nSpecifying Channel IDs in Web Requests\n\nStr L Meaning Example\nNET 2 Network code \"IU\"\nSTA 5 Station code \"ANMO\"\nLOC 2 Location identifier \"00\"\nCHA 3 Channel code \"BHZ\"\n\nA channel is uniquely specified by four substrings (NET, STA, LOC, CHA), which can be formatted as a String or a String array. Each substring has a maximum safe length of L characters (column 2 in the table).\n\nAcceptable Channel ID Formats\n\nType Example\nString \"PB.B004.01.BS1, PB.B004.01.BS2\"\nArray{String, 1} [\"PB.B004.01.BS1\",\"PB.B004.01.BS2\"]\nArray{String, 2} [\"PB\" \"B004\" \"01\" \"BS?\"; \"PB\" \"B001\" \"01\" \"BS?\"]\n\nThe LOC field can be blank in FDSN requests with getdata; for example, `chans=\"UW.ELK..EHZ\"; getdata(\"FDSN\", chans)`.\n\nSeedLink only\n\nFor SeedLink functions (seedlink!, has_stream, etc.), channel IDs can include a fifth field (i.e. NET.STA.LOC.CHA.T) to set the \"type\" flag (one of DECOTL, for Data, Event, Calibration, blOckette, Timing, or Logs). Note that SeedLink calibration, timing, and logs are not in the scope of SeisBase.\n\nSee also: get_data, seedlink\n\n\n\n\n\n","category":"function"},{"location":"Intro/getting_help/","page":"Getting Help","title":"Getting Help","text":"Answers: how do I specify channels in a web request? Outputs channel id syntax to stdout.","category":"page"},{"location":"Intro/getting_help/","page":"Getting Help","title":"Getting Help","text":"seis_www","category":"page"},{"location":"Intro/getting_help/#SeisBase.seis_www","page":"Getting Help","title":"SeisBase.seis_www","text":"String Source\nBGR http://eida.bgr.de\nEMSC http://www.seismicportal.eu\nETH http://eida.ethz.ch\nGEONET http://service.geonet.org.nz\nGFZ http://geofon.gfz-potsdam.de\nICGC http://ws.icgc.cat\nINGV http://webservices.ingv.it\nIPGP http://eida.ipgp.fr\nIRIS http://service.iris.edu\nIRISPH5 http://service.iris.edu/ph5ws/\nISC http://isc-mirror.iris.washington.edu\nKOERI http://eida.koeri.boun.edu.tr\nLMU http://erde.geophysik.uni-muenchen.de\nNCEDC http://service.ncedc.org\nNIEP http://eida-sc3.infp.ro\nNOA http://eida.gein.noa.gr\nORFEUS http://www.orfeus-eu.org\nRESIF http://ws.resif.fr\nSCEDC http://service.scedc.caltech.edu\nTEXNET http://rtserve.beg.utexas.edu\nUSGS http://earthquake.usgs.gov\nUSP http://sismo.iag.usp.br\n\n\n\n\n\n","category":"constant"},{"location":"Intro/getting_help/","page":"Getting Help","title":"Getting Help","text":"Answers: which servers are available for FDSN queries? Outputs the FDSN server list to stdout.","category":"page"},{"location":"Intro/getting_help/","page":"Getting Help","title":"Getting Help","text":"TimeSpec","category":"page"},{"location":"Intro/getting_help/#SeisBase.TimeSpec","page":"Getting Help","title":"SeisBase.TimeSpec","text":"TimeSpec = Union{Real, DateTime, String}\n\nTime Specification\n\nMost functions that allow time specification use two reserved keywords to track time: s (start/begin) time and t (termination/end) time. Exact behavior of each is given in the table below.\n\nReal numbers are interpreted as seconds\nDateTime values are as in the Dates package\nStrings should use ISO 8601 without time zone (YYYY-MM-DDThh:mm:ss.s); UTC is assumed. Equivalent Unix strftime format codes are %Y-%m-%dT%H:%M:%S or %FT%T.\n\nparsetimewin Behavior\n\nIn all cases, parsetimewin outputs a pair of strings, sorted so that the first string corresponds to the earlier start time.\n\ntypeof(s) typeof(t) Behavior\nDateTime DateTime sort\nDateTime Real add t seconds to s, then sort\nDateTime String convert t => DateTime, then sort\nDateTime String convert t => DateTime, then sort\nReal DateTime add s seconds to t, then sort\nReal Real treat s, t as seconds from current time; sort\nString DateTime convert s => DateTime, then sort\nString Real convert s => DateTime, then sort\n\nSpecial behavior with (Real, Real): s and t are converted to seconds from the start of the current minute. Thus, for s=0 (the default), the data request begins (or ends) at the start of the minute in which the request is submitted.\n\nSee also: Dates.DateTime\n\n\n\n\n\n","category":"type"},{"location":"Intro/getting_help/#All-About-Keywords","page":"Getting Help","title":"All About Keywords","text":"","category":"section"},{"location":"Intro/getting_help/","page":"Getting Help","title":"Getting Help","text":"Invoke keywords help with ?SeisBase.KW for complete information on SeisBase shared keywords and meanings.","category":"page"},{"location":"Processing/data_processing/#Data-Processing","page":"Data Processing","title":"Data Processing","text":"","category":"section"},{"location":"Processing/data_processing/","page":"Data Processing","title":"Data Processing","text":"Supported processing operations are described below.","category":"page"},{"location":"Processing/data_processing/","page":"Data Processing","title":"Data Processing","text":"In most cases, a \"safe\" version of each function can be invoked to create a new object with the processed output.","category":"page"},{"location":"Processing/data_processing/","page":"Data Processing","title":"Data Processing","text":"Any function that can logically operate on a single-channel object will do so. Any function that operates on a SeisData object can be applied to the :data field of a SeisEvent object.","category":"page"},{"location":"Processing/data_processing/#Basic-Operations","page":"Data Processing","title":"Basic Operations","text":"","category":"section"},{"location":"Processing/data_processing/","page":"Data Processing","title":"Data Processing","text":"These functions have no keywords that fundamentally change their behavior.","category":"page"},{"location":"Processing/data_processing/","page":"Data Processing","title":"Data Processing","text":"demean!\ndetrend!\nenv!\nnanfill!\nresample!\nunscale!","category":"page"},{"location":"Processing/data_processing/#SeisBase.demean!","page":"Data Processing","title":"SeisBase.demean!","text":"demean!(S::SeisData[; chans=CC, irr=false])\n\nRemove the mean from all channels i with S.fs[i] > 0.0. Specify irr=true to also remove the mean from irregularly sampled channels (with S.fs[i] == 0.0). Specifying a channel list with chans=CC restricts processing to channels CC.\n\ndemean!(C::SeisChannel)\n\nRemove the mean from data in C.\n\nIgnores NaNs.\n\n\n\n\n\n","category":"function"},{"location":"Processing/data_processing/#SeisBase.detrend!","page":"Data Processing","title":"SeisBase.detrend!","text":"detrend!(S::SeisData[; chans=CC, n=1]))\n\nRemove the linear trend from channels CC. Ignores NaNs.\n\nTo remove a higher-order polynomial fit than a linear trend, choose n >1.\n\ndetrend!(C::SeisChanel[; n=1]))\n\nRemove the linear trend from data in C. Ignores NaNs.\n\nTo remove a higher-order polynomial fit than a linear trend, choose n>1.\n\nwarning: Warning\ndetrend! does not check for data gaps; if this is problematic, call ungap!(S, m=true) first!\n\n\n\n\n\n","category":"function"},{"location":"Processing/data_processing/#SeisBase.env!","page":"Data Processing","title":"SeisBase.env!","text":"env!(S::GphysData[, chans=CC, v=V])\nenv(S::GphysData)\n\nCompute the envelope of channel data in S. Only affects regularly-sampled channels.\n\nIn-place conversion of S.x[i] ==> Env(S.x[i]) (≡ |H(S.x[i])|, where H denotes the Hilbert transform).\n\nKeywords\n\nchans=CC: only process channels in CC (with fs > 0.0).\nv=V: verbosity.\n\n\n\n\n\n","category":"function"},{"location":"Processing/data_processing/#SeisBase.nanfill!","page":"Data Processing","title":"SeisBase.nanfill!","text":"nanfill!(S::SeisData)\nnanfill!(C::SeisChannel)\n\nFor each channel i in S, replace all NaNs in S.x[i] with the mean of non-NaN values.\n\n\n\n\n\n","category":"function"},{"location":"Processing/data_processing/#SeisBase.resample!","page":"Data Processing","title":"SeisBase.resample!","text":"resample!(S::SeisData [, chans=CC, fs=FS])\nresample(S::SeisData [, chans=CC, fs=FS])\n\nResample data in S to FS. If keyword fs is not specified, data are resampled to the lowest non-zero value in S.fs[CC].Note that a poor choice of FS can lead to upsampling and other undesirable behavior.\n\nUse keyword chans=CC to only resample channel numbers CC. By default, all channels i with S.fs[i] > 0.0 are resampled.\n\nresample!(C::SeisChannel, fs::Float64)\nresample(C::SeisChannel, fs::Float64)\n\nResample C.x to fs.\n\n\n\n\n\n","category":"function"},{"location":"Processing/data_processing/#SeisBase.unscale!","page":"Data Processing","title":"SeisBase.unscale!","text":"unscale!(S::GphysData[, chans=CC, irr=false])\n\nDivide out the gains of all channels i where S.fs[i] > 0.0. Specify irr=true to also remove the gains of irregularly-sampled channels. Use keyword chans=CC to only resample channel numbers CC.\n\n\n\n\n\n","category":"function"},{"location":"Processing/data_processing/#Customizable-Operations","page":"Data Processing","title":"Customizable Operations","text":"","category":"section"},{"location":"Processing/data_processing/#Convert-Seismograms","page":"Data Processing","title":"Convert Seismograms","text":"","category":"section"},{"location":"Processing/data_processing/","page":"Data Processing","title":"Data Processing","text":"Seismograms can be converted to or from displacement, velocity, or acceleration using convert_seis:","category":"page"},{"location":"Processing/data_processing/","page":"Data Processing","title":"Data Processing","text":"convert_seis!","category":"page"},{"location":"Processing/data_processing/#SeisBase.convert_seis!","page":"Data Processing","title":"SeisBase.convert_seis!","text":"convert_seis!(S[, chans=CC, units_out=UU, v=V])\nconvert_seis(S, chans=CC, units_out=UU, v=V])\nconvert_seis!(C[, units_out=UU, v=V])\nconvert_seis(CC, units_out=UU, v=V)\n\nConvert all seismic data channels in S to velocity seismograms, differentiating or integrating as needed.\n\nKeywords\n\nunits_out=UU specifies output units.\nDefault: \"m/s\".\nAllowed: \"m\", \"m/s\", or \"m/s2\". (SeisBase uses Unicode (UTF-8) UCUM units.)\nv=V sets verbosity.\nchans=CC restricts seismogram conversion to seismic data channels within CC.\nchans can be an Integer, UnitRange, or Array{Int64,1}.\nBy default, all seismic data channels in S are converted (if needed).\nThis does not allow convert_seis! to work on non-seismic data.\n\nwarning: Seismogram length at `Float32` precision\nconvert_seis! becomes less reversible as seismograms lengthen, particularly at Float32 precision,  due to loss of significance. At single (Float32) precision, seismograms with N ~ 10^6 samples are reconstructable after one conversion  (e.g. \"m\" ==> \"m/s\" can be reversed, with output approximately equal to the original data). After multiple  conversions (i.e., \"m\" ==> \"m/s²\" or \"m/s²\" ==> \"m\"), Float32 data cannot be perfectly reconstructed in this way,  though reconstruction errors are typically small.\n\nwarning: Rectangular Integration\nIntegration is always rectangular; irregularly-spaced seismic data are not processed by convert_seis. Summation  uses an in-place variant of Kahan-Babuška-Neumaier summation\n\nReferences\n\nNeumaier, A. (1974). \"Rundungsfehleranalyse einiger Verfahren zur Summation endlicher Summen\" [Rounding Error Analysis of Some Methods for Summing Finite Sums]. Zeitschrift für Angewandte Mathematik und Mechanik (in German). 54 (1): 39-51. doi:10.1002/zamm.19740540106.\n\n\n\n\n\n","category":"function"},{"location":"Processing/data_processing/#Fill-Gaps","page":"Data Processing","title":"Fill Gaps","text":"","category":"section"},{"location":"Processing/data_processing/","page":"Data Processing","title":"Data Processing","text":"ungap!","category":"page"},{"location":"Processing/data_processing/#SeisBase.ungap!","page":"Data Processing","title":"SeisBase.ungap!","text":"ungap!(S[, chans=CC, m=true, tap=false])\nungap(S[, chans=CC, m=true, tap=false])\n\nFill time gaps in each channel of S with the mean of the channel data.\n\nungap!(C[, m=true, tap=false])\nungap(C[, m=true, tap=false])\n\nAs above for GphysChannel object C.\n\nKeywords\n\nchans=CC: only ungap channels CC.\nm=false: this flag fills gaps with NaNs instead of the mean.\ntap=true: taper data before filling gaps.\n\nwarning: Warning\nIf channel segments aren't in chronological order, call merge before using ungap.\n\n\n\n\n\n","category":"function"},{"location":"Processing/data_processing/#Merge","page":"Data Processing","title":"Merge","text":"","category":"section"},{"location":"Processing/data_processing/","page":"Data Processing","title":"Data Processing","text":"merge!","category":"page"},{"location":"Processing/data_processing/#Base.merge!","page":"Data Processing","title":"Base.merge!","text":"merge!(S::SeisData, U::SeisData[, prune_only=true])\n\nMerge channels of two SeisData structures.\n\nMerge two GphysData structures. For timeseries data, a single-pass merge-and-prune operation is applied to value pairs whose sample times are separated by less than half the sampling interval.\n\nmerge!(S::SeisData[, prune_only=true])\n\n\"Flatten\" a SeisData structure by merging channels with identical properties.\n\nIf prune_only=true, the only action taken is deletion of empty and duplicate channels; merge!(S, U, prune_only=true) is identical to an in-place S+U.\n\n\n\n\n\n","category":"function"},{"location":"Processing/data_processing/#Merge-Behavior","page":"Data Processing","title":"Merge Behavior","text":"","category":"section"},{"location":"Processing/data_processing/","page":"Data Processing","title":"Data Processing","text":"Which channels merge?","category":"page"},{"location":"Processing/data_processing/","page":"Data Processing","title":"Data Processing","text":"Channels merge if they have identical values for id, fs, loc, resp, and units.\nAn unset loc, resp, or units field matches any set value in the corresponding field of another channel.","category":"page"},{"location":"Processing/data_processing/","page":"Data Processing","title":"Data Processing","text":"What happens to merged fields?","category":"page"},{"location":"Processing/data_processing/","page":"Data Processing","title":"Data Processing","text":"The essential properties above are preserved.\nOther fields are combined.\nMerged channels with different :name values use the name of the channel with the latest data before the merge; other names are logged to :notes.","category":"page"},{"location":"Processing/data_processing/","page":"Data Processing","title":"Data Processing","text":"What does merge resolve?","category":"page"},{"location":"Processing/data_processing/","page":"Data Processing","title":"Data Processing","text":"Issue Resolution\nEmpty channels Delete\nDuplicated channels Delete duplicate channels\nDuplicated windows in channel(s) Delete duplicate windows\nMultiple channels, same properties [1] Merge to a single channel\nChannel with out-of-order time windows Sort in chronological order\nOverlapping windows, identical data, time-aligned Windows merged\nOverlapping windows, identical data, small time offset [2] Time offset corrected, windows merged\nOverlapping windows, non-identical data Samples averaged, windows merged","category":"page"},{"location":"Processing/data_processing/","page":"Data Processing","title":"Data Processing","text":"[1]: \"Properties\" here are id, fs, loc, resp, and units.\n[2]: Data offset >4 sample intervals are treated as overlapping and non-identical.","category":"page"},{"location":"Processing/data_processing/","page":"Data Processing","title":"Data Processing","text":"When SeisBase Won't Merge SeisBase does not combine data channels if any of the five fields above are non-empty and different. For example, if a GphysData object S contains two channels, each with id \"XX.FOO..BHZ\", but one has fs=100 Hz and the other fs=50 Hz, merge! does nothing.","category":"page"},{"location":"Processing/data_processing/","page":"Data Processing","title":"Data Processing","text":"It's best to merge only unprocessed data. Data segments that were processed independently (e.g. detrended) will be averaged pointwise when merged, which can easily leave data in an unusuable state.","category":"page"},{"location":"Processing/data_processing/","page":"Data Processing","title":"Data Processing","text":"mseis!","category":"page"},{"location":"Processing/data_processing/#SeisBase.mseis!","page":"Data Processing","title":"SeisBase.mseis!","text":"mseis!(S::SeisData, U...)\n\nMerge multiple SeisData structures at once. The first argument (merge target) must be a SeisData structure. Subsequent structures can be any type T <: Union{GphysData, GphysChannel, SeisEvent}.\n\nmseis!(C::GphysChannel, U...)\n\nMerge all channels in U that match channel C into object C. To be merged, a channel must match on fields :id, :fs, :loc, :resp, :units.\n\nSee also: merge!\n\n\n\n\n\n","category":"function"},{"location":"Processing/data_processing/#Seismic-Instrument-Response","page":"Data Processing","title":"Seismic Instrument Response","text":"","category":"section"},{"location":"Processing/data_processing/","page":"Data Processing","title":"Data Processing","text":"translate_resp!","category":"page"},{"location":"Processing/data_processing/#SeisBase.translate_resp!","page":"Data Processing","title":"SeisBase.translate_resp!","text":"translate_resp!(S, resp_new[, chans=CC, wl=γ])\ntranslate_resp(S, resp_new[, chans=CC, wl=γ])\n\nTranslate the instrument response of seismic data channels CC in S to resp_new. Replaces field :resp with resp_new for all affected channels.\n\nremove_resp!(S, chans=CC, wl=γ])\nremove_resp(S, chans=CC, wl=γ])\n\nRemove (flatten to DC) the instrument response of seismic data channels cha in S. Replaces field :resp with the appropriate (all-pass) response.\n\ntranslate_resp!(Ch, resp_new[, wl=γ])\ntranslate_resp(Ch, resp_new[, wl=γ])\n\nTranslate the instrument response of seismic data in SeisChannel object Ch to resp_new. Replaces field :resp with resp_new.\n\nremove_resp!(Ch[, chans=CC, wl=γ])\nremove_resp(Ch[, chans=CC, wl=γ])\n\nRemove (flatten to DC) the instrument response of seismic data in Ch. Replaces field :resp with the appropriate (all-pass) response.\n\nKeywords\n\nchans=CC restricts response translation to channel(s) CC. By default, all seismic data channels have responses translated to resp_new.\nwl=γ sets the waterlevel to γ (default: γ = eps(Float32) ≈ ~1f-7)\n\nThe waterlevel is the minimum magnitude (absolute value) of the normalized old frequency response; in other words,  if the old frequency response has a maximum magnitude of 1.0, then no response coefficient can be lower than g.  This is useful to prevent \"divide by zero\" errors, but setting it too high will cause errors.\n\nInteraction with the :resp field\n\ntranslate_resp and remove_resp only work on a channel i that satisfies S.resp[i] <: PZResp, PZResp64, MultiStageResp. In the last case, S.resp[i].stage[1] must be a PZResp or PZResp64, only the first stage of the response is changed, and the stage gain is ignored; instead, the sensitivity S.resp[i].stage[1].a0 is used.\n\nPoles and zeros should be rad/s\n\nAlways check when loading from an unsupported data format. Responses read from station XML are corrected to rad/s automatically (most use rad/s); responses read from a SACPZ or SEED RESP file already use rad/s.\n\nwarning: Warning\nResponse translation doesn't guarantee causality; if this is a problem, detrend and taper first!\n\n\n\n\n\n","category":"function"},{"location":"Processing/data_processing/#Precision-and-Memory-Optimization","page":"Data Processing","title":"Precision and Memory Optimization","text":"","category":"section"},{"location":"Processing/data_processing/","page":"Data Processing","title":"Data Processing","text":"To optimize speed and memory use, instrument response translation maps data to Complex{Float32} before translation; thus, with Float64 data, there can be minor rounding errors.","category":"page"},{"location":"Processing/data_processing/","page":"Data Processing","title":"Data Processing","text":"Instrument responses are also memory-intensive. The minimum memory consumption to translate the response of a gapless Float32 SeisChannel object is ~7x the size of the object itself.","category":"page"},{"location":"Processing/data_processing/","page":"Data Processing","title":"Data Processing","text":"More precisely, for an object S (of Type <: GphysData or GphysChannel), translation requires memory ~ 2 kB + the greater of (7x the size of the longest Float32 segment, or 3.5x the size of the longest Float64 segment). Translation uses four vectors – three complex and one real – that are updated and dynamically resized as the algorithm loops over each segment:","category":"page"},{"location":"Processing/data_processing/","page":"Data Processing","title":"Data Processing","text":"Old response container: Array{Complex{Float32,1}}(undef, Nx)\nNew response container: Array{Complex{Float32,1}}(undef, Nx)\nComplex data container: Array{Complex{Float32,1}}(undef, Nx)\nReal frequencies for FFT: Array{Float32,1}(undef, Nx)","category":"page"},{"location":"Processing/data_processing/","page":"Data Processing","title":"Data Processing","text":"...where Nx is the number of samples in the longest segment in S.","category":"page"},{"location":"Processing/data_processing/#Causality","page":"Data Processing","title":"Causality","text":"","category":"section"},{"location":"Processing/data_processing/","page":"Data Processing","title":"Data Processing","text":"Response translation adds no additional processing to guarantee causality. At a minimum, most users will want to call detrend and taper before translating instrument responses.","category":"page"},{"location":"Processing/data_processing/#Synchronize","page":"Data Processing","title":"Synchronize","text":"","category":"section"},{"location":"Processing/data_processing/","page":"Data Processing","title":"Data Processing","text":"sync!","category":"page"},{"location":"Processing/data_processing/#SeisBase.sync!","page":"Data Processing","title":"SeisBase.sync!","text":"sync!(S::GphysData)\n\nSynchronize the start times of all data in S to begin at or after the last start time in S.\n\nsync!(S[, s=TS, t=TT, pad=false, v=V])\n\nSynchronize all data in S to start no earlier than TS and terminate no later than TT, with verbosity level V.\n\nBy default, a channel with mean μᵢ = mean(S.x[i]) that begins after TS is prepended with μᵢ to begin exactly at TS; similarly, if keyword t is used, μᵢ is appended so that data ends at TT. If pad=false, channels that begin after TS or end before TT are not extended in either direction.\n\nFor regularly-sampled channels, gaps between the specified and true times are filled with the mean; this isn't possible with irregularly-sampled data.\n\nSpecifying start time (s=)\n\ns=\"last\": (Default) sync to the last start time of any channel in S.\ns=\"first\": sync to the first start time of any channel in S.\nA numeric value is treated as an epoch time (?time for details).\nA DateTime is treated as a DateTime. (see Dates.DateTime for details.)\nAny string other than \"last\" or \"first\" is parsed as a DateTime.\n\nSpecifying end time (t=)\n\nt=\"none\": (Default) end times are not synchronized.\nt=\"last\": synchronize all channels to end at the last end time in S.\nt=\"first\" synchronize to the first end time in S.\nnumeric, datetime, and non-reserved strings are treated as for s=.\n\nSee also: TimeSpec, Dates.DateTime, parsetimewin\n\nwarning: Warning\nsync! calls prune!; empty channels will be deleted.\n\n\n\n\n\n","category":"function"},{"location":"Processing/data_processing/#Taper","page":"Data Processing","title":"Taper","text":"","category":"section"},{"location":"Processing/data_processing/","page":"Data Processing","title":"Data Processing","text":"taper!","category":"page"},{"location":"Processing/data_processing/#SeisBase.taper!","page":"Data Processing","title":"SeisBase.taper!","text":"taper!(C[; t_max::Real=10.0, α::Real=0.05, N_min::Int64=10])\n\nCosine taper all time-series data in C. Tapers each segment of each channel that contains at least N_min total samples.\n\ntaper!(S[; chans=CC, t_max::Real=10.0, α::Real=0.05, N_min::Int64=10])\n\nCosine taper each segment of time-series data in GphysChannel object C that contains at least N_min total samples.\n\nDoes not modify irregularly-sampled data channels.\n\nKeywords:\n\nchans: Only taper the specified channels.\nN_min: Data segments with N < N_min total samples are not tapered.\nt_max: Maximum taper edge in seconds.\nα: Taper edge area; as for a Tukey window, the first and last 100*α% of\n\nsamples in each window are tapered, up to t_max seconds of data.\n\nSee also: DSP.Windows.tukey\n\n\n\n\n\n","category":"function"},{"location":"Processing/data_processing/#Zero-Phase-Filter","page":"Data Processing","title":"Zero-Phase Filter","text":"","category":"section"},{"location":"Processing/data_processing/","page":"Data Processing","title":"Data Processing","text":"filtfilt!","category":"page"},{"location":"Processing/data_processing/#SeisBase.filtfilt!","page":"Data Processing","title":"SeisBase.filtfilt!","text":"filtfilt!(S::GphysData[; KWs])\n\nApply zero-phase filter to S.x.\n\nfiltfilt!(C::GphysChannel[; KWs])\n\nApply zero-phase filter to C.x\n\nKeywords control filtering behavior; specify as e.g. filtfilt!(S, fl=0.1, np=2, rt=\"Lowpass\").\n\nKeywords\n\nName Default Type Description\nchans (all) [1] channel numbers to filter\nfl 1.0 Float64 lower corner frequency [Hz] [2]\nfh 15.0 Float64 upper corner frequency [Hz] [2]\nnp 4 Int64 number of poles\nrp 10 Int64 pass-band ripple (dB)\nrs 30 Int64 stop-band ripple (dB)\nrt \"Bandpass\" String response type (type of filter)\ndm \"Butterworth\" String design mode (name of filter)\n\nAllowed types are Integer, UnitRange, and Array{Int64, 1}.\nBy convention, the lower corner frequency (fl) is used in a Highpass\n\nfilter, and fh is used in a Lowpass filter.\n\nDefault filtering KW values can be changed by adjusting the Shared Keywords,  e.g., SeisBase.KW.Filt.np = 2 changes the default number of poles to 2.\n\nSee also: DSP.jl documentation\n\n\n\n\n\n","category":"function"},{"location":"Processing/data_processing/#Troubleshooting-NaNs-in-Output","page":"Data Processing","title":"Troubleshooting NaNs in Output","text":"","category":"section"},{"location":"Processing/data_processing/","page":"Data Processing","title":"Data Processing","text":"NaNs in the output of filtering operations (e.g., filtfilt!, translate_resp!) are nearly always the result of zeros in the denominator of the filter transfer function.","category":"page"},{"location":"Processing/data_processing/","page":"Data Processing","title":"Data Processing","text":"This is not a bug in SeisBase.","category":"page"},{"location":"Processing/data_processing/","page":"Data Processing","title":"Data Processing","text":"In particular, the increased speed of data processing at 32-bit precision comes with an increased risk of NaN output. The reason is that 32-bit machine epsilon (eps(Float32) in Julia) is ~1.0e-7; by comparison, 64-bit machine epsilon is ~1.0e-16.","category":"page"},{"location":"Processing/data_processing/","page":"Data Processing","title":"Data Processing","text":"Please check for common signal processing issues before reporting NaNs to SeisBase maintainers. For example:","category":"page"},{"location":"Processing/data_processing/#Filtering","page":"Data Processing","title":"Filtering","text":"","category":"section"},{"location":"Processing/data_processing/","page":"Data Processing","title":"Data Processing","text":"Is the pass band too narrow?\nIs the lower corner frequency too close to DC?\nIs the filter order (or number of poles) too high?","category":"page"},{"location":"Processing/data_processing/#Instrument-Responses","page":"Data Processing","title":"Instrument Responses","text":"","category":"section"},{"location":"Processing/data_processing/","page":"Data Processing","title":"Data Processing","text":"Are the roll-off frequencies of the old and new responses too far apart?\nIs the water level appropriate for the data scaling?","category":"page"},{"location":"Processing/data_processing/#Suggested-References","page":"Data Processing","title":"Suggested References","text":"","category":"section"},{"location":"Processing/data_processing/","page":"Data Processing","title":"Data Processing","text":"Oppenheim, A.V., Buck, J.R. and Schafer, R.W., 2009. Discrete-time signal processing (3rd edition). Upper Saddle River, NJ, USA: Prentice Hall.\nOrfanidis, S.J., 1995. Introduction to signal processing. Upper Saddle River, NJ, USA: Prentice Hall.","category":"page"},{"location":"ReadingFiles/timeseries/#time_series_file","page":"Time-Series Files","title":"Time-Series Files","text":"","category":"section"},{"location":"ReadingFiles/timeseries/","page":"Time-Series Files","title":"Time-Series Files","text":"read_data!\nread_data","category":"page"},{"location":"ReadingFiles/timeseries/#SeisBase.read_data!","page":"Time-Series Files","title":"SeisBase.read_data!","text":"read_data!(S, fmt, filestr [, keywords])\n\nRead data in file format fmt matching file pattern filestr into SeisData object S.\n\nread_data!(S, filestr [, keywords])\n\nRead from files matching file pattern filestr into SeisData object S. Calls guess(filestr) to identify the file type based on the first file matching pattern filestr. Much slower than manually specifying file type.\n\nFormats: ah1, ah2, bottle, geocsv, geocsv.slist, lennartz, mseed, passcal, suds, sac, segy, SeisBase, slist, uw, win32\nKeywords: cf, full, jst, memmap, nxadd, nxnew, strict, swap, v, vl\n\nThis function is fully described in the official documentation at https://SeisBase.readthedocs.io/ (TODO: Change site) in section Time-Series Files.\n\nSee also: SeisBase.KW, get_data, guess, rseis\n\n\n\n\n\n","category":"function"},{"location":"ReadingFiles/timeseries/#SeisBase.read_data","page":"Time-Series Files","title":"SeisBase.read_data","text":"S = read_data(fmt, filestr [, keywords])\n\nRead data in file format fmt matching file pattern filestr into SeisData object S.\n\nS = read_data(filestr [, keywords])\n\nRead from files matching file pattern filestr into SeisData object S. Calls guess(filestr) to identify the file type based on the first file matching pattern filestr. Much slower than manually specifying file type.\n\nFormats: ah1, ah2, bottle, geocsv, geocsv.slist, lennartz, mseed, passcal, suds, sac, segy, SeisBase, slist, uw, win32\nKeywords: cf, full, jst, memmap, nxadd, nxnew, strict, swap, v, vl\n\nThis function is fully described in the official documentation at https://SeisBase.readthedocs.io/ (TODO: Change site) in section Time-Series Files.\n\nSee also: SeisBase.KW, get_data, guess, rseis\n\n\n\n\n\n","category":"function"},{"location":"ReadingFiles/timeseries/#Supported-File-Formats","page":"Time-Series Files","title":"Supported File Formats","text":"","category":"section"},{"location":"ReadingFiles/timeseries/","page":"Time-Series Files","title":"Time-Series Files","text":"File Format String Strict Match\nAH-1 ah1 id, fs, gain, loc, resp, units\nAH-2 ah2 id, fs, gain, loc, resp\nBottle (UNAVCO) bottle id, fs, gain\nGeoCSV, time-sample pair geocsv id\nGeoCSV, sample list geocsv.slist id\nLennartz ASCII lenartz id, fs\nMini-SEED mseed id, fs\nPASSCAL SEG Y passcal id, fs, gain, loc\nSAC sac id, fs, gain\nSEG Y (rev 0 or rev 1) segy id, fs, gain, loc\nSeisBase SeisBase id, fs, gain, loc, resp, units\nSLIST (ASCII sample list) slist id, fs\nSUDS suds id\nUW data file uw id, fs, gain, units\nWin32 win32 id, fs, gain, loc, resp, units","category":"page"},{"location":"ReadingFiles/timeseries/","page":"Time-Series Files","title":"Time-Series Files","text":"Strings are case-sensitive to prevent any performance impact from using matches and/or lowercase().","category":"page"},{"location":"ReadingFiles/timeseries/","page":"Time-Series Files","title":"Time-Series Files","text":"Note that read_data with file format \"SeisBase\" largely exists as a convenience wrapper; it reads only the first SeisBase object from each file that can be converted to a SeisData structure. For more complicated read operations, rseis should be used.","category":"page"},{"location":"ReadingFiles/timeseries/","page":"Time-Series Files","title":"Time-Series Files","text":"Warning: GeoCSV files must be Unix text files; DOS text files, whose lines end in \"\\r\\n\", will not read properly. Convert with dos2unix or equivalent Windows Powershell commands.","category":"page"},{"location":"ReadingFiles/timeseries/#Supported-Keywords","page":"Time-Series Files","title":"Supported Keywords","text":"","category":"section"},{"location":"ReadingFiles/timeseries/","page":"Time-Series Files","title":"Time-Series Files","text":"Keyword Used By Type Default Meaning\ncf win32 String \\\"\\\" win32 channel info filestr\nfull [1]_ Bool false read full header into :misc?\nll segy UInt8 0x00 set loc in :id? (see below)\nmemmap * Bool false use Mmap.mmap to buffer file?\nnx_add [2]_ Int64 360000 minimum size increase of x\nnx_new [3]_ Int64 86400000 length(x) for new channels\njst win32 Bool true are sample times JST (UTC+9)?\nswap [4]_ Bool true byte swap?\nstrict * Bool true use strict match?\nv * Integer 0 verbosity\nvl * Bool 0 verbose source logging? [5]_","category":"page"},{"location":"ReadingFiles/timeseries/","page":"Time-Series Files","title":"Time-Series Files","text":"[1]: used by ah1, ah2, sac, segy, suds, uw; information read into misc varies by file format.\n[2]: see table below.\n[3]: used by bottle, mseed, suds, win32\n[4]: used by bottle, mseed, suds, win32\n[5]: used by mseed, passcal, segy; swap is automatic for sac.","category":"page"},{"location":"ReadingFiles/timeseries/#Performance-Tips","page":"Time-Series Files","title":"Performance Tips","text":"","category":"section"},{"location":"ReadingFiles/timeseries/","page":"Time-Series Files","title":"Time-Series Files","text":"mmap=true improves read speed for some formats, particularly ASCII readers, but requires caution. In our benchmarks, the following significant (>3%) speed changes are observed:","category":"page"},{"location":"ReadingFiles/timeseries/","page":"Time-Series Files","title":"Time-Series Files","text":"Significant speedup: ASCII formats, including metadata formats\nSlight speedup: mini-SEED\nSignificant slowdown: SAC","category":"page"},{"location":"ReadingFiles/timeseries/","page":"Time-Series Files","title":"Time-Series Files","text":"With mseed or win32 data, adjust nx_new and nx_add based on the sizes of","category":"page"},{"location":"ReadingFiles/timeseries/","page":"Time-Series Files","title":"Time-Series Files","text":"the data vectors that you expect to read. If the largest has Nmax samples, and the smallest has Nmin, we recommend nx_new=Nmin and nx_add=Nmax-Nmin.","category":"page"},{"location":"ReadingFiles/timeseries/","page":"Time-Series Files","title":"Time-Series Files","text":"Default values can be changed in SeisBase keywords, e.g.,","category":"page"},{"location":"ReadingFiles/timeseries/","page":"Time-Series Files","title":"Time-Series Files","text":"SeisBase.KW.nx_new = 60000\nSeisBase.KW.nx_add = 360000","category":"page"},{"location":"ReadingFiles/timeseries/","page":"Time-Series Files","title":"Time-Series Files","text":"The system-wide defaults are nx_new=86400000 and nx_add=360000. Using these values with very small jobs will greatly decrease performance.","category":"page"},{"location":"ReadingFiles/timeseries/","page":"Time-Series Files","title":"Time-Series Files","text":"strict=true may slow read_data based on the fields matched as part of","category":"page"},{"location":"ReadingFiles/timeseries/","page":"Time-Series Files","title":"Time-Series Files","text":"the file format. In general, any file format that can match on more than id and fs will read slightly slower with this option.","category":"page"},{"location":"ReadingFiles/timeseries/#Channel-Matching","page":"Time-Series Files","title":"Channel Matching","text":"","category":"section"},{"location":"ReadingFiles/timeseries/","page":"Time-Series Files","title":"Time-Series Files","text":"By default, read_data continues a channel if data read from file matches the channel id (field :id). In some cases this is not enough to guarantee a good match. With strict=true, read_data matches against fields :id, :fs, :gain, :loc, :resp, and :units. However, not all of these fields are stored natively in all file formats. Column \"Strict Match\" in the first table lists which fields are stored (and can be logically matched) in each format with strict=true.","category":"page"},{"location":"ReadingFiles/timeseries/#Examples","page":"Time-Series Files","title":"Examples","text":"","category":"section"},{"location":"ReadingFiles/timeseries/","page":"Time-Series Files","title":"Time-Series Files","text":"S = read_data(\"uw\", \"99011116541W\", full=true)\nRead UW-format data file 99011116541W\nStore full header information in misc\nread_data!(S, \"sac\", \"MSH80*.SAC\")\nRead SAC-format files matching string pattern MSH80*.SAC\nRead into existing SeisData object S\nS = read_data(\"win32\", \"20140927*.cnt\", cf=\"20140927*ch\", nx_new=360000)\nRead win32-format data files with names matching pattern 2014092709*.cnt\nUse ASCII channel information filenames that match pattern 20140927*ch\nAssign new channels an initial size of nx_new samples","category":"page"},{"location":"ReadingFiles/timeseries/#Memory-Mapping","page":"Time-Series Files","title":"Memory Mapping","text":"","category":"section"},{"location":"ReadingFiles/timeseries/","page":"Time-Series Files","title":"Time-Series Files","text":"memmap=true is considered unsafe because Julia language handling of SIGBUS/SIGSEGV and associated risks is undocumented as of SeisBase v1.0.0. Thus, for example, we don't know what a connection failure during memory-mapped file I/O does. In some languages, this situation without additional signal handling was notorious for corrupting files.","category":"page"},{"location":"ReadingFiles/timeseries/","page":"Time-Series Files","title":"Time-Series Files","text":"Under no circumstances should mmap=true be used to read files directly from a drive whose host device power management is independent of the destination computer's. This includes all work flows that involve reading files directly into memory from a connected data logger. It is not a sufficient workaround to set a data logger to \"always on\".","category":"page"},{"location":"ReadingFiles/timeseries/#Format-Descriptions-and-Notes","page":"Time-Series Files","title":"Format Descriptions and Notes","text":"","category":"section"},{"location":"ReadingFiles/timeseries/","page":"Time-Series Files","title":"Time-Series Files","text":"Additional format information can be accessed from the command line by typing SeisBase.formats(\"FMT\") where FMT is the format name; keys(SeisBase.formats) for a list.","category":"page"},{"location":"ReadingFiles/timeseries/","page":"Time-Series Files","title":"Time-Series Files","text":"AH (Ad-Hoc) was developed as a machine-independent seismic data format based on External Data Representation (XDR).\nBottle is a single-channel format maintained by UNAVCO (USA).\nGeoCSV: an extension of \"human-readable\", tabular file format Comma-Separated Values (CSV).\nLennartz: a variant of sample list (SLIST) used by Lennartz portable digitizers.\nPASSCAL: A single- channel variant of SEG Y with no file header, developed by PASSCAL/New Mexico Tech and used with PASSCAL field equipment.\nSAC: the Seismic Analysis Code data format, originally developed by LLNL for the eponymous command-line interpreter.\nSEED: adopted by the International Federation of Digital Seismograph Networks (FDSN) as an omnibus seismic data standard. mini-SEED is a data-only variant that uses only data blockettes.\nSEG Y: Society of Exploration Geophysicists data format. Common in the energy industry. Developed and maintained by SEG.\nSLIST: An ASCII file with a one-line header and data written to file in ASCII string format.\nSUDS: A similar format to SEED, developed by the US Geological Survey (USGS) in the late 1980s.\nUW: created in the 1970s by the Pacific Northwest Seismic Network (PNSN), USA, for event archival; used until the early 2000s.\nWin32: maintained by the National Research Institute for Earth Science and Disaster Prevention (NIED), Japan. Continuous data are divided into files that contain a minute of data from multiple channels stored in one-second segments.","category":"page"},{"location":"ReadingFiles/timeseries/#Format-Specific-Information","page":"Time-Series Files","title":"Format-Specific Information","text":"","category":"section"},{"location":"ReadingFiles/timeseries/#segy","page":"Time-Series Files","title":"SEG Y","text":"","category":"section"},{"location":"ReadingFiles/timeseries/","page":"Time-Series Files","title":"Time-Series Files","text":"Only SEG Y rev 0 and rev 1 with standard headers are supported. The following are known support limitations:","category":"page"},{"location":"ReadingFiles/timeseries/","page":"Time-Series Files","title":"Time-Series Files","text":"A few SEG Y headers are partially implemented or unused. These will be refined as we obtain more test data with standardized SEG Y headers and known results.\nNot all SEG Y files use the gain formula in the SEG Y rev 1 manual. Users are urged to consult equipment manufacturers and/or coders whose software converts proprietary data formats to SEG Y.\nSeisBase does not use the Textual File Header (file bytes 1-3600) or Extended Textual File Header records, as these were never standardized. Specify full=true to read the raw bytes into vectors in :misc. These byte vectors can be parsed manually by the user after file read.","category":"page"},{"location":"ReadingFiles/timeseries/#Setting-the-Location-Subfield","page":"Time-Series Files","title":"Setting the Location Subfield","text":"","category":"section"},{"location":"ReadingFiles/timeseries/","page":"Time-Series Files","title":"Time-Series Files","text":"The location subfield within :id (\"LL\" in NN.SSSS.LL.CC) is normally blank, but can be set from an arbitrary Int32 quantity in SEG Y. The reason for this behavior is that SEG Y has at least six \"recommended\" quantities that can indicate a unique channel. Use one by passing the corresponding value from the table below to keyword \"ll\":","category":"page"},{"location":"ReadingFiles/timeseries/","page":"Time-Series Files","title":"Time-Series Files","text":"Code U Bytes :misc Usual trace header quantity\n0x00    None (Default); don't set LL\n0x01 Y 001-004 traceseqline Trace sequence number within line\n0x02 Y 005-008 traceseqfile Trace sequence number within SEG Y file\n0x03  009-012 rec_no Original field record number\n0x04 Y 013-016 channel_no Trace number within original field record\n0x05  017-020 energysrcpt Energy source point number\n0x06  021-024 cdp Ensemble number\n0x07 ? 025-028 traceinensemble Trace number within the ensemble\n0x08  037-040 src-rec_dist Distance from center of source point\n0x09  041-044 rec_ele Receiver group elevation\n0x0a  045-048 src_ele Surface elevation at source\n0x0b  049-052 src_dep Source depth below surface (positive)\n0x0c  053-056 recdatumele Datum elevation at receiver group\n0x0d  057-060 srcdatumele Datum elevation at source\n0x0e  061-064 srcwaterdep Water depth at source\n0x0f  065-068 recwaterdep Water depth at group\n0x10  073-076 src_x Source coordinate - X\n0x11  077-080 src_y Source coordinate - Y\n0x12  081-084 rec_x Group coordinate - X\n0x13  085-088 rec_y Group coordinate - Y\n0x14  181-184 cdp_x X coordinate of ensemble (CDP) position\n0x15  185-188 cdp_y Y coordinate of ensemble (CDP) position\n0x16  189-192 inline_3d For 3-D poststack data, in-line number\n0x17  193-196 crossline_3d For 3-D poststack data, cross-line number\n0x18  197-200 shot_point Shotpoint number (2-D post-stack data)\n0x19  205-208 trans_mant Transduction Constant (mantissa)\n0x1a ? 233-236 unassigned_1 Unassigned — For optional information\n0x1b ? 237-240 unassigned_2 Unassigned — For optional information","category":"page"},{"location":"ReadingFiles/timeseries/","page":"Time-Series Files","title":"Time-Series Files","text":"A SEG Y file usually increments one (or more) of 0x01, 0x02, or 0x04 for each trace. Unfortunately, we can't imagine any way to use all three, or even two, in a SEGY-compliant channel ID.","category":"page"},{"location":"ReadingFiles/timeseries/","page":"Time-Series Files","title":"Time-Series Files","text":"Warning: for any quantity above,","category":"page"},{"location":"ReadingFiles/timeseries/","page":"Time-Series Files","title":"Time-Series Files","text":"Numeric values >1296 lead to nonstandard characters in the LL subfield\nNumeric values >7200 lead to non-unique :id fields, with undefined results\nNumeric values >9216 cause read_data to throw an InexactError","category":"page"},{"location":"ReadingFiles/timeseries/#UW","page":"Time-Series Files","title":"UW","text":"","category":"section"},{"location":"ReadingFiles/timeseries/","page":"Time-Series Files","title":"Time-Series Files","text":"Only UW v2 (UW-2) data files are supported. We have no reason to believe that any UW-1 data files are in circulation, and external converters to UW-2 exist.","category":"page"},{"location":"ReadingFiles/timeseries/#Win32","page":"Time-Series Files","title":"Win32","text":"","category":"section"},{"location":"ReadingFiles/timeseries/","page":"Time-Series Files","title":"Time-Series Files","text":"Use older channel files with caution. They were not controlled by any central authority until the late 2010s. Inconsistencies between different versions of the same channel file were found by SeisBase developers as recently as 2015.","category":"page"},{"location":"ReadingFiles/timeseries/#Other-File-I/O-Functions","page":"Time-Series Files","title":"Other File I/O Functions","text":"","category":"section"},{"location":"ReadingFiles/timeseries/","page":"Time-Series Files","title":"Time-Series Files","text":"rseis\nsachdr\nsegyhdr","category":"page"},{"location":"ReadingFiles/timeseries/#SeisBase.rseis","page":"Time-Series Files","title":"SeisBase.rseis","text":"rseis(fstr::String[, c::Array{Int64,1}=C, v::Integer=0, memmap::Bool=false])\n\nRead SeisBase files matching file pattern fstr into memory. If an array of record indices is passed to keyword c, only those record indices are read from each file.\n\nSet v>0` to control verbosity.\nSet memmap=true` to use memory mapping. Faster but potentially unsafe.\n\n\n\n\n\n","category":"function"},{"location":"ReadingFiles/timeseries/#SeisBase.sachdr","page":"Time-Series Files","title":"SeisBase.sachdr","text":"sachdr(f)\n\nPrint formatted SAC headers from file f to stdout. Does not accept wildcard file strings.\n\n\n\n\n\n","category":"function"},{"location":"ReadingFiles/timeseries/#SeisBase.segyhdr","page":"Time-Series Files","title":"SeisBase.segyhdr","text":"segyhdr(f[; passcal=false, ll=LL, swap=false])\n\nPrint formatted, sorted SEG-Y headers of file f to stdout. Use keyword passcal=true for PASSCAL/NMT modified SEG Y; use swap=true for big-endian PASSCAL. See SeisBase read_data documentation for ll codes.\n\n\n\n\n\n","category":"function"},{"location":"Submodules/nodal/#Nodal","page":"Nodal","title":"Nodal","text":"","category":"section"},{"location":"Submodules/nodal/","page":"Nodal","title":"Nodal","text":"The Nodal submodule is intended to handle data from nodal arrays. Nodal arrays differ from standard seismic data in that the start and end times of data segments are usually synchronized.","category":"page"},{"location":"Submodules/nodal/#Reading-Nodal-Data-Files","page":"Nodal","title":"Reading Nodal Data Files","text":"","category":"section"},{"location":"Submodules/nodal/","page":"Nodal","title":"Nodal","text":"SeisBase.Nodal.read_nodal","category":"page"},{"location":"Submodules/nodal/#SeisBase.Nodal.read_nodal","page":"Nodal","title":"SeisBase.Nodal.read_nodal","text":"S = read_nodal(fmt, filestr [, keywords])\n\nRead nodal data from file filestr into new NodalData object S.\n\nKeywords\n\nKW Type Default Used By Meaning\nchans ChanSpec Int64[] all channel numbers to read in\nnn String \"N0\" all network name in :id\ns TimeSpec  silixa start time [1]\nt TimeSpec  silixa end time\nv Integer 0 silixa verbosity\n\nSpecial behavior: Real values supplied to s= and t= are treated as seconds from file begin;   most SeisBase functions treat Real as seconds relative to current time.\n\nNon-Standard Behavior\n\nReal values supplied to keywords s= and t= are treated as seconds relative to file begin time.  Most SeisBase functions that accept TimeSpec arguments treat Real values as seconds relative to now().\n\nSupported File Formats\n\nFile Format String Notes\nSilixa TDMS silixa Limited support; see below\nSEG Y segy Field values are different from read_data output\n\nSilixa TDMS Support Status\n\nCurrently only reads file header and samples from first block\nNot yet supported (test files needed):\nfirst block additional samples\nsecond block\nsecond block additional samples\nAwaiting manufacturer clarification:\nparameters in :info\nposition along cable; currently loc.(x,y,z) = 0.0 for all channels\nfrequency response; currently resp is an all-pass placeholder\n\nNodal SEG Y Support Status\n\nSee SEG Y Support.\n\nSee also: TimeSpec, parsetimewin, read_data\n\n\n\n\n\n","category":"function"},{"location":"Submodules/nodal/#Working-with-NodalData-objects","page":"Nodal","title":"Working with NodalData objects","text":"","category":"section"},{"location":"Submodules/nodal/","page":"Nodal","title":"Nodal","text":"NodalData objects have one major structural difference from SeisData objects: the usual data field :x is a set of views to an Array{Float32, 2} (equivalent to a Matrix{Float32}) stored in field :data. This allows the user to apply two-dimensional data processing operations directly to the data matrix.","category":"page"},{"location":"Submodules/nodal/#NodalData-Assumptions","page":"Nodal","title":"NodalData Assumptions","text":"","category":"section"},{"location":"Submodules/nodal/","page":"Nodal","title":"Nodal","text":"S.t[i] is the same for all i.\nS.fs[i] is constant for all i.\nlength(S.x[i]) is constant for all i.","category":"page"},{"location":"Submodules/nodal/#Other-Differences-from-SeisData-objects","page":"Nodal","title":"Other Differences from SeisData objects","text":"","category":"section"},{"location":"Submodules/nodal/","page":"Nodal","title":"Nodal","text":"Operations like push! and append! must regenerate :data using hcat(), and therefore consume a lot of memory.\nAttempting to push! or append! channels of unequal length throws an error.\nAttempting to push! or append! same-length channels with different :t or :fs won't synchronize them! You will instead have columns in :data that aren't time-aligned.\nIrregularly-sampled data (:fs = 0.0) are not supported.","category":"page"},{"location":"Submodules/nodal/#Types","page":"Nodal","title":"Types","text":"","category":"section"},{"location":"Submodules/nodal/","page":"Nodal","title":"Nodal","text":"SeisBase.Nodal.NodalLoc\nSeisBase.Nodal.NodalData\nSeisBase.Nodal.NodalChannel","category":"page"},{"location":"Submodules/nodal/#SeisBase.NodalLoc","page":"Nodal","title":"SeisBase.NodalLoc","text":"NodalLoc\n\nInstrument position along a nodal array\n\nNodal location. Currently only stores position along optical cable.\n\nx::Float64 (meters)\ny::Float64 (meters)\nz::Float64 (meters)\n\n\n\n\n\n","category":"type"},{"location":"Submodules/nodal/#SeisBase.Nodal.NodalData","page":"Nodal","title":"SeisBase.Nodal.NodalData","text":"NodalData\n\nSeisData variant for multichannel nodal array data.\n\nNodalChannel\n\nSeisChannel variant for a channel from a nodal array.\n\nFields\n\nField Description\n:n Number of sensors\n:ox Origin longitude\n:oy Origin latitude\n:oz Origin elevation\n:info Critical array info, shared by all sensors. [1]\n:id Channel id. Uses NET.STA.LOC.CHA format when possible\n:name Freeform channel name\n:loc Location (position) vector; only accepts NodalLoc\n:fs Sampling frequency in Hz\n:gain Scalar gain\n:resp Instrument response\n:units String describing data units. UCUM standards are assumed.\n:src Freeform string describing data source.\n:misc Dictionary for non-critical information.\n:notes Timestamped notes; includes automatically-logged information.\n:t Matrix of time gaps in integer μs, formatted [Sample# Length]\n:data Matrix underlying time-series data\n:x Views into :data corresponding to each channel\n\nNot present in, or retained by, NodalChannel objects.\n\nSee also: SeisData, InstrumentPosition, InstrumentResponse\n\n\n\n\n\n","category":"type"},{"location":"Submodules/nodal/#SeisBase.Nodal.NodalChannel","page":"Nodal","title":"SeisBase.Nodal.NodalChannel","text":"NodalChannel\n\nA single channel of data from a nodal array. Similar to a SeisChannel object.\n\nSee NodalData.\n\n\n\n\n\n","category":"type"},{"location":"Submodules/seishdf/#seishdf","page":"SeisHDF","title":"SeisHDF","text":"","category":"section"},{"location":"Submodules/seishdf/","page":"SeisHDF","title":"SeisHDF","text":"This submodule contains dedicated support for seismic subformats of the HDF5 file format.","category":"page"},{"location":"Submodules/seishdf/#Additional-Functions","page":"SeisHDF","title":"Additional Functions","text":"","category":"section"},{"location":"Submodules/seishdf/","page":"SeisHDF","title":"SeisHDF","text":"SeisBase.SeisHDF.asdf_waux\nSeisBase.SeisHDF.asdf_rqml\nSeisBase.SeisHDF.asdf_wqml\nSeisBase.SeisHDF.read_asdf_evt\nSeisBase.SeisHDF.scan_hdf5","category":"page"},{"location":"Submodules/seishdf/#SeisBase.SeisHDF.asdf_waux","page":"SeisHDF","title":"SeisBase.SeisHDF.asdf_waux","text":"asdf_waux(hdf_out, path, X)\n\nWrite X to AuxiliaryData/path in hdf_out. If an object already exists at AuxiliaryData/path, it will be deleted and overwritten with X.\n\n\n\n\n\n","category":"function"},{"location":"Submodules/seishdf/#SeisBase.SeisHDF.asdf_rqml","page":"SeisHDF","title":"SeisBase.SeisHDF.asdf_rqml","text":"(H,R) = asdf_rqml(fpat::String)\n\nRead QuakeXML (qml) from ASDF file(s) matching file string pattern fpat. Returns:\n\nH, Array{SeisHdr,1}\nR, Array{SeisSrc,1}\n\n\n\n\n\n","category":"function"},{"location":"Submodules/seishdf/#SeisBase.SeisHDF.asdf_wqml","page":"SeisHDF","title":"SeisBase.SeisHDF.asdf_wqml","text":"asdf_wqml(fname, SHDR::Array{SeisHdr,1}, SSRC::Array{SeisSrc,1}[, KWs])\nasdf_wqml(fname, H::SeisHdr, R::SeisSrc[, KWs])\n\nWrite QuakeXML (qml) to \"QuakeML/\" dataset in ASDF file fname from SHDR and SSRC.\n\nasdf_wqml(fname, evt::SeisEvent[, KWs])\nasdf_wqml(fname, evt::Array{SeisEvent,1}[, KWs])\n\nAs above, for the :hdr and :source fields of evt.\n\nKW Type Default Meaning\novr Bool false overwrite QML in existing ASDF file? [1]\nv Integer 0 verbosity\n\nBy default, data are appended to the existing contents of \"QuakeML/\".\n\nwarning: Warning\nTo write data from R ∈ SSRC, it must be true that R.eid == H.id for some H ∈ SHDR.\n\nSee also: write_qml\n\n\n\n\n\n","category":"function"},{"location":"Submodules/seishdf/#SeisBase.SeisHDF.read_asdf_evt","page":"SeisHDF","title":"SeisBase.SeisHDF.read_asdf_evt","text":"EventCat = read_asdf_evt(filestr, event_id::Union{String, Regex}[, KWs])\n\nRead data in seismic HDF5 format with ids matching event_id from files matching pattern filestr. Returns an array of SeisEvent structures.\n\nEventCat = read_asdf_evt(filestr, [, KWs])\n\nRead data in seismic HDF5 format from files matching pattern filestr into SeisEvent structures. Matches any event ID in any matching file.\n\nKW Type Default Meaning\nmsr Bool true read full (MultiStageResp) instrument resp?\nv Integer 0 verbosity\n\nSee also: TimeSpec, parsetimewin, read_data, read_hdf5\n\n\n\n\n\n","category":"function"},{"location":"Submodules/seishdf/#SeisBase.SeisHDF.scan_hdf5","page":"SeisHDF","title":"SeisBase.SeisHDF.scan_hdf5","text":"scan_hdf5(hdf)\n\nScan HDF5 archive hdf and return station names with waveform data contained therein as a list of Strings formatted \"nn.sssss\" (network.station).\n\nscan_hdf5(hdf, level=\"trace\")\n\nScan HDF5 archive hdf and return channel names with waveform data contained therein as a list of Strings formatted \"nn.sssss.ll.ccc\" (network.station.location.channel).\n\n\n\n\n\n","category":"function"},{"location":"Downloading/web_services/#Web-Services","page":"Web Services","title":"Web Services","text":"","category":"section"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"Data requests use get_data! for FDSN, IRISWS, and IRIS PH5WS data services; for (near) real-time streaming, see SeedLink.","category":"page"},{"location":"Downloading/web_services/#Time-Series-Data","page":"Web Services","title":"Time-Series Data","text":"","category":"section"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"get_data!\nget_data","category":"page"},{"location":"Downloading/web_services/#SeisBase.get_data!","page":"Web Services","title":"SeisBase.get_data!","text":"get_data!(S, method, chans [, keywords])\n\nSee get_data for details.\n\n\n\n\n\n","category":"function"},{"location":"Downloading/web_services/#SeisBase.get_data","page":"Web Services","title":"SeisBase.get_data","text":"S = get_data(method, chans [, keywords])\n\nWrapper to web requests for time-series data. Request data using method from channels chans using keywords KWs, storing the output in S.\n\nMethods: FDSN, IRIS, PH5\nChannels: See ?web_chanspec\nKeywords: autoname, demean, detrend, fmt, msr, nd, opts, rad, reg, rr, s, si, src, t, taper, to, ungap, unscale, v, w, xf, y\n\nThis function is fully described in the official documentation at https://SeisBase.readthedocs.io/ under subheading Web Requests.\n\nSee also: web_chanspec, parsetimewin, seis_www, SeisBase.KW\n\n\n\n\n\n","category":"function"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"Retrieve time-series data from a web archive to SeisData structure S.","category":"page"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"method \"FDSN\": :FDSNWS dataselect. Change FDSN servers with keyword src using the server list (see ?seis_www). \"IRIS\": IRISWS timeseries. \"PH5\": PH5WS timeseries.","category":"page"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"channels Channels to retrieve – string, string array, or parameter file. Type ?chanspec at the Julia prompt for more info.","category":"page"},{"location":"Downloading/web_services/#Keywords","page":"Web Services","title":"Keywords","text":"","category":"section"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"Shared Keywords","category":"page"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"fmt, nd, opts, rad, reg, si, to, v, w, y","category":"page"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"Seismic Processing Keywords","category":"page"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"unscale: divide gain from data after download\ndemean: demean data after download\ndetrend: detrend data after download\ntaper: taper data after download\nungap: remove gaps in data after download\nrr: remove seismic instrument response after download","category":"page"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"Other Keywords","category":"page"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"autoname: determine file names from channel ID?\nmsr: get instrument responses as MultiStageResonse? (\"FDSN\" only)\ns: start time\nt: termination (end) time\nxf: XML file name for output station XML","category":"page"},{"location":"Downloading/web_services/#Special-Behavior","page":"Web Services","title":"Special Behavior","text":"","category":"section"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"autoname=true attempts to emulate IRISWS channel file naming conventions. For this to work, however, each request must return exactly one channel. A wildcard (\"*\" or \"?\") in a channel string deactivates autoname=true.\nSeismic processing keywords follow an order of operations that matches the ordering of the above list.\nIRISWS requests always remove the stage zero gain on the server side, because the service doesn't include the gain constant in the request. This ensures that :gain is accurate in SeisBase.\nIRISWS requests don't fill :loc or :resp fields in mini-SEED and don't fill the :resp field in SAC. For cross-format consistency, the stage-zero (scalar) gain is removed from any request to IRISWS and the :gain field in such channels is 1.0.","category":"page"},{"location":"Downloading/web_services/#Data-Formats","page":"Web Services","title":"Data Formats","text":"","category":"section"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"SeisBase supports the following data format strings in timeseries web requests, subject to the limitations of the web service:","category":"page"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"\"miniseed\" or \"mseed\" for mini-SEED\n\"sac\" or \"sacbl\" for binary little-endian SAC\n\"geocsv\" for two-column (tspair) GeoCSV","category":"page"},{"location":"Downloading/web_services/#Station-Metadata","page":"Web Services","title":"Station Metadata","text":"","category":"section"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"FDSNsta","category":"page"},{"location":"Downloading/web_services/#SeisBase.FDSNsta","page":"Web Services","title":"SeisBase.FDSNsta","text":"S = FDSNsta(chans, KW)\n\nRetrieve station/channel info for formatted parameter file (or string) chans into an empty SeisData structure.\n\nStandard keywords: rad, reg, src, to, v\n\nOther keywords:\n\nmsr: get MultiStage (full) responses?\ns: Start time\nt: Termination (end) time\nxf: Name of XML file to save station metadata\n\nSee also: web_chanspec, parsetimewin, get_data!, SeisBase.KW\n\n\n\n\n\n","category":"function"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"Fill channels chans of SeisData structure S with information retrieved from remote station XML files by web query.","category":"page"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"Shared Keywords","category":"page"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"src, to, v","category":"page"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"Other Keywords","category":"page"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"msr: get instrument responses as MultiStageResonse?\ns: start time\nt: termination (end) time\nxf: XML file name for output station XML","category":"page"},{"location":"Downloading/web_services/#Examples","page":"Web Services","title":"Examples","text":"","category":"section"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"Note that the \"src\" keyword is used by FDSNWS dataselect queries, but not by IRISWS or PH5WS timeseries queries.","category":"page"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"Download 10 minutes of data from four stations at Mt. St. Helens (WA, USA), delete the low-gain channels, and save as SAC files in the current directory.","category":"page"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"S = get_data(\"FDSN\", \"CC.VALT, UW.SEP, UW.SHW, UW.HSR\", src=\"IRIS\", t=-600)\nS -= \"UW.SHW..ELZ\"\nS -= \"UW.HSR..ELZ\"\nwritesac(S)","category":"page"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"Get 5 stations, 2 networks, all channels, last 600 seconds of data at IRIS","category":"page"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"CHA = \"CC.PALM, UW.HOOD, UW.TIMB, CC.HIYU, UW.TDH\"\nTS = u2d(time())\nTT = -600\nS = get_data(\"FDSN\", CHA, src=\"IRIS\", s=TS, t=TT)","category":"page"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"A request to FDSN Potsdam, time-synchronized, with some verbosity","category":"page"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"ts = \"2011-03-11T06:00:00\"\nte = \"2011-03-11T06:05:00\"\nR = get_data(\"FDSN\", \"GE.BKB..BH?\", src=\"GFZ\", s=ts, t=te, v=1, y=true)","category":"page"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"Get channel information for strain and seismic channels at station PB.B001:","category":"page"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"S = FDSNsta(\"CC.VALT..,PB.B001..BS?,PB.B001..E??\")","category":"page"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"Get trace data from IRISws from TS to TT at channels CHA","category":"page"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"S = SeisData()\nCHA = \"UW.TDH..EHZ, UW.VLL..EHZ, CC.VALT..BHZ\"\nTS = u2d(time()-86400)\nTT = 600\nget_data!(S, \"IRIS\", CHA, s=TS, t=TT)","category":"page"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"Get synchronized trace data from IRISws with a 55-second timeout on HTTP requests, written directly to disk.","category":"page"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"CHA = \"UW.TDH..EHZ, UW.VLL..EHZ, CC.VALT..BHZ\"\nTS = u2d(time())\nTT = -600\nS = get_data(\"IRIS\", CHA, s=TS, t=TT, y=true, to=55, w=true)","category":"page"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"Request 10 minutes of continuous vertical-component data from a small May 2016 earthquake swarm at Mt. Hood, OR, USA, and cosine taper after download:","category":"page"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"STA = \"UW.HOOD.--.BHZ,CC.TIMB.--.EHZ\"\nTS = \"2016-05-16T14:50:00\"; TE = 600\nS = get_data(\"IRIS\", STA, s=TS, t=TE)","category":"page"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"Grab data from a predetermined time window in two different formats","category":"page"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"ts = \"2016-03-23T23:10:00\"\nte = \"2016-03-23T23:17:00\"\nS = get_data(\"IRIS\", \"CC.JRO..BHZ\", s=ts, t=te, fmt=\"sacbl\")\nT = get_data(\"IRIS\", \"CC.JRO..BHZ\", s=ts, t=te, fmt=\"miniseed\")","category":"page"},{"location":"Downloading/web_services/#Bad-Requests","page":"Web Services","title":"Bad Requests","text":"","category":"section"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"Failed data requests are saved to special channels whose IDs begin with \"XX.FAIL\". The HTTP response message is stored as a String in :misc[\"msg\"]; display to STDOUT with println(stdout, S.misc[i][\"msg\"]).","category":"page"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"Unparseable data requests are saved to special channels whose IDs begin with \"XX.FMT\". The raw response bytes are stored as an Array{UInt8,1} in :misc[\"raw\"] and can be dumped to file or parsed with external programs as needed.","category":"page"},{"location":"Downloading/web_services/","page":"Web Services","title":"Web Services","text":"One special channel is created per bad request.","category":"page"},{"location":"ReadingFiles/metadata/#Metadata-Files","page":"Metadata Files","title":"Metadata Files","text":"","category":"section"},{"location":"ReadingFiles/metadata/","page":"Metadata Files","title":"Metadata Files","text":"read_meta!\nread_meta","category":"page"},{"location":"ReadingFiles/metadata/#SeisBase.read_meta!","page":"Metadata Files","title":"SeisBase.read_meta!","text":"read_meta!(S, fmt, filestr [, keywords])\n\nGeneric wrapper for reading channel metadata (i.e., instrument parameters, responses). Reads metadata in file format fmt matching file pattern filestr into S.\n\nThis function is fully described in the official documentation at https://SeisBase.readthedocs.io/ under subheading Metadata Files.\n\nArguments\n\nfmt::String: Lowercase string describing the file format.\nfpat::Union{String, Vector{String}}: Read files with names matching pattern filepat. Supports wildcards.\n\nFor information on keyword arguments, see SeisBase.KW\n\nSee also: SeisBase.KW, get_data, read_data\n\n\n\n\n\n","category":"function"},{"location":"ReadingFiles/metadata/#SeisBase.read_meta","page":"Metadata Files","title":"SeisBase.read_meta","text":"S = read_meta(fmt, filestr [, keywords])\n\nCreates a new SeisData object then calls read_meta! to read metadata in file format fmt matching file pattern filestr into S.\n\nSee also: read_meta!\n\n\n\n\n\n","category":"function"},{"location":"ReadingFiles/metadata/#Supported-File-Formats","page":"Metadata Files","title":"Supported File Formats","text":"","category":"section"},{"location":"ReadingFiles/metadata/","page":"Metadata Files","title":"Metadata Files","text":"File Format String\nDataless SEED dataless\nFDSN Station XML sxml\nSACPZ sacpz\nSEED RESP resp","category":"page"},{"location":"ReadingFiles/metadata/","page":"Metadata Files","title":"Metadata Files","text":"Warning: Dataless SEED, SACPZ, and RESP files must be Unix text files; DOS text files, whose lines end in \"\\r\\n\", will not read properly. Convert with dos2unix or equivalent Windows Powershell commands.","category":"page"},{"location":"ReadingFiles/metadata/#Supported-Keywords","page":"Metadata Files","title":"Supported Keywords","text":"","category":"section"},{"location":"ReadingFiles/metadata/","page":"Metadata Files","title":"Metadata Files","text":"KW Used By Type Default Meaning\nmemmap all Bool false use Mmap.mmap to buffer file?\nmsr sxml Bool false read full MultiStageResp?\ns all TimeSpec  Start time\nt all TimeSpec  Termination (end) time\nunits resp Bool false fill in MultiStageResp  units?\n dataless   \nv all Integer 0 verbosity","category":"page"},{"location":"ReadingFiles/metadata/","page":"Metadata Files","title":"Metadata Files","text":"Note: mmap=true improves read speed for ASCII formats but requires caution. Julia language handling of SIGBUS/SIGSEGV and associated risks is unknown and undocumented.","category":"page"},{"location":"ReadingFiles/xml/#XML-Meta-Data","page":"XML Meta-Data","title":"XML Meta-Data","text":"","category":"section"},{"location":"ReadingFiles/xml/","page":"XML Meta-Data","title":"XML Meta-Data","text":"SeisBase can read and write the following XML metadata formats:","category":"page"},{"location":"ReadingFiles/xml/","page":"XML Meta-Data","title":"XML Meta-Data","text":"QuakeML Version 1.2\nStationXML Version 1.1","category":"page"},{"location":"ReadingFiles/xml/#StationXML","page":"XML Meta-Data","title":"StationXML","text":"","category":"section"},{"location":"ReadingFiles/xml/","page":"XML Meta-Data","title":"XML Meta-Data","text":"read_sxml(fpat::String, s::String, t::String, memmap::Bool, msr::Bool, v::Integer)","category":"page"},{"location":"ReadingFiles/xml/","page":"XML Meta-Data","title":"XML Meta-Data","text":"note: Note\nThis function is not exported anywhere","category":"page"},{"location":"ReadingFiles/xml/","page":"XML Meta-Data","title":"XML Meta-Data","text":"Read FDSN StationXML files matching string pattern fpat into a new SeisData object.","category":"page"},{"location":"ReadingFiles/xml/","page":"XML Meta-Data","title":"XML Meta-Data","text":"Keywords:","category":"page"},{"location":"ReadingFiles/xml/","page":"XML Meta-Data","title":"XML Meta-Data","text":"s: start time. Format \"YYYY-MM-DDThh:mm:ss\", e.g., \"0001-01-01T00:00:00\".\nt: termination (end) time. Format \"YYYY-MM-DDThh:mm:ss\".\nmsr: (Bool) read instrument response info as MultiStageResp?","category":"page"},{"location":"ReadingFiles/xml/","page":"XML Meta-Data","title":"XML Meta-Data","text":"msr=true processes XML files to give full response information at every documented stage of the acquisition process: sampling, digitization, FIR filtering, decimation, etc.","category":"page"},{"location":"ReadingFiles/xml/","page":"XML Meta-Data","title":"XML Meta-Data","text":"How often is MultiStageResp needed? Almost never. By default, the :resp field of each channel contains a simple instrument response with poles, zeros, sensitivity (:a0), and sensitivity frequency (:f0). Very few use cases require more detail.","category":"page"},{"location":"ReadingFiles/xml/#quakeml","page":"XML Meta-Data","title":"QuakeML","text":"","category":"section"},{"location":"ReadingFiles/xml/","page":"XML Meta-Data","title":"XML Meta-Data","text":"read_qml","category":"page"},{"location":"ReadingFiles/xml/#SeisBase.Quake.read_qml","page":"XML Meta-Data","title":"SeisBase.Quake.read_qml","text":"EvCat, EvSrc = read_qml(fpat::String)\n\nRead QuakeML files matching string pattern fpat. Returns an array of SeisHdr objects as EvCat and an array of SeisSrc objects as EvSrc, such that EvCat[i] and EvSrc[i] describe the preferred location (origin) and preferred event source (focal mechanism or moment tensor) of event i.\n\nIf multiple focal mechanisms, locations, or magnitudes are present in a single Event element of the XML file(s),  the following rules are used to select one of each per event:\n\nFocalMechanism     1. preferredFocalMechanismID if present     2. Solution with best-fitting moment tensor     3. First FocalMechanism element\n\nMagnitude     1. preferredMagnitudeID if present     2. Magnitude whose ID matches MomentTensor/derivedOriginID     3. Last moment magnitude (lowercase scale name begins with \"mw\")     4. First Magnitude element\n\nOrigin     1. preferredOriginID if present     2. derivedOriginID from the chosen MomentTensor element     3. First Origin element\n\nNon-essential QuakeML data are saved to misc in each SeisHdr or SeisSrc object as appropriate.\n\n\n\n\n\n","category":"function"},{"location":"ReadingFiles/xml/","page":"XML Meta-Data","title":"XML Meta-Data","text":"Read QuakeML files matching string pattern fpat. Returns a tuple containing an array of SeisHdr objects H and an array of SeisSrc objects R. Each pair (H[i], R[i]) describes the preferred location (origin, SeisHdr) and event source (focal mechanism or moment tensor, SeisSrc) of event i.","category":"page"},{"location":"ReadingFiles/xml/","page":"XML Meta-Data","title":"XML Meta-Data","text":"If multiple focal mechanisms, locations, or magnitudes are present in a single Event element of the XML file(s), the following rules are used to select one of each per event:","category":"page"},{"location":"ReadingFiles/xml/","page":"XML Meta-Data","title":"XML Meta-Data","text":"FocalMechanism","category":"page"},{"location":"ReadingFiles/xml/","page":"XML Meta-Data","title":"XML Meta-Data","text":"preferredFocalMechanismID if present\nSolution with best-fitting moment tensor\nFirst FocalMechanism element","category":"page"},{"location":"ReadingFiles/xml/","page":"XML Meta-Data","title":"XML Meta-Data","text":"Magnitude","category":"page"},{"location":"ReadingFiles/xml/","page":"XML Meta-Data","title":"XML Meta-Data","text":"preferredMagnitudeID if present\nMagnitude whose ID matches MomentTensor/derivedOriginID\nLast moment magnitude (lowercase scale name begins with \"mw\")\nFirst Magnitude element","category":"page"},{"location":"ReadingFiles/xml/","page":"XML Meta-Data","title":"XML Meta-Data","text":"Origin","category":"page"},{"location":"ReadingFiles/xml/","page":"XML Meta-Data","title":"XML Meta-Data","text":"preferredOriginID if present\nderivedOriginID from the chosen MomentTensor element\nFirst Origin element","category":"page"},{"location":"ReadingFiles/xml/","page":"XML Meta-Data","title":"XML Meta-Data","text":"Non-essential QuakeML data are saved to misc in each SeisHdr or SeisSrc object as appropriate.","category":"page"},{"location":"Intro/first_steps/#First-Steps","page":"First Steps","title":"First Steps","text":"","category":"section"},{"location":"Intro/first_steps/","page":"First Steps","title":"First Steps","text":"SeisBase is designed around easy, fluid, and fast data access. At the most basic level, SeisBase uses an array-like structure called a SeisChannel for single-channel data, and a multichannel structure named SeisData.","category":"page"},{"location":"Intro/first_steps/#Start-Here","page":"First Steps","title":"Start Here","text":"","category":"section"},{"location":"Intro/first_steps/","page":"First Steps","title":"First Steps","text":"Create a new, empty SeisChannel object with","category":"page"},{"location":"Intro/first_steps/","page":"First Steps","title":"First Steps","text":"Ch = SeisChannel()","category":"page"},{"location":"Intro/first_steps/","page":"First Steps","title":"First Steps","text":"The meanings of the field names are explained here; you can also type SeisChannel at the Julia prompt. You can edit field values manually, e.g., returning to the code block above,","category":"page"},{"location":"Intro/first_steps/","page":"First Steps","title":"First Steps","text":"Ch = SeisChannel()\nCh.loc = GeoLoc(lat=-90.0, lon=0.0, el=2835.0, az=0.0, inc=0.0)\nCh.name = \"South pole\"","category":"page"},{"location":"Intro/first_steps/","page":"First Steps","title":"First Steps","text":"or you can set them with keywords at creation:","category":"page"},{"location":"Intro/first_steps/","page":"First Steps","title":"First Steps","text":"Ch = SeisChannel(name=\"Templo de San José de La Floresta, Ajijic\", fs=40.0)","category":"page"},{"location":"Intro/first_steps/","page":"First Steps","title":"First Steps","text":"Note that Strings in field names support full Unicode, so even graffiti can be saved and read back in. This is useful for data containing non-English characters.","category":"page"},{"location":"Intro/first_steps/","page":"First Steps","title":"First Steps","text":"SeisData structures are collections of channel data. They can be created with the SeisData() command, which can optionally create any number of empty channels at a time, e.g.,","category":"page"},{"location":"Intro/first_steps/","page":"First Steps","title":"First Steps","text":"S = SeisData()      # empty structure, no channels\nS1 = SeisData(12)   # empty 12-channel structure","category":"page"},{"location":"Intro/first_steps/","page":"First Steps","title":"First Steps","text":"They can be explored similarly:","category":"page"},{"location":"Intro/first_steps/","page":"First Steps","title":"First Steps","text":"S = SeisData(1)\nS.name[1] = \"South pole\"\nS.loc[1] = GeoLoc(lat=-90.0, lon=0.0, el=2835.0, az=0.0, inc=0.0)","category":"page"},{"location":"Intro/first_steps/","page":"First Steps","title":"First Steps","text":"A collection of channels becomes a SeisData structure; for example,","category":"page"},{"location":"Intro/first_steps/","page":"First Steps","title":"First Steps","text":"L = GeoLoc(lat=46.1967, lon=-122.1875, el=1440.0, az=0.0, inc=0.0)\nS = SeisData(SeisChannel(), SeisChannel())\nS = SeisData(randSeisData(5), SeisChannel(),\n      SeisChannel(id=\"UW.SEP..EHZ\", name=\"Darth Exploded\", loc=L))","category":"page"},{"location":"Intro/first_steps/","page":"First Steps","title":"First Steps","text":"You can push channels onto existing SeisData structures, like adding one key to a dictionary. For example,","category":"page"},{"location":"Intro/first_steps/","page":"First Steps","title":"First Steps","text":"push!(S, Ch)","category":"page"},{"location":"Intro/first_steps/","page":"First Steps","title":"First Steps","text":"copies Ch to a new channel in S. Note that the new S[3] is not a view into Ch. This is deliberate, as otherwise the workspace quickly becomes a mess of redundant channels. Clean up with Ch =  to free memory before moving on.","category":"page"},{"location":"Intro/first_steps/#Operations-on-SeisData-structures","page":"First Steps","title":"Operations on SeisData structures","text":"","category":"section"},{"location":"Intro/first_steps/","page":"First Steps","title":"First Steps","text":"We're now ready for a short tutorial of what we can do with data structures. In the commands below, as in most of this documentation, Ch is a SeisChannel object and S is a SeisData object.","category":"page"},{"location":"Intro/first_steps/#Adding-channels-to-a-SeisData-structure","page":"First Steps","title":"Adding channels to a SeisData structure","text":"","category":"section"},{"location":"Intro/first_steps/","page":"First Steps","title":"First Steps","text":"You've already seen one way to add a channel to SeisData: push!(S, SeisChannel()) adds an empty channel. Here are others:","category":"page"},{"location":"Intro/first_steps/","page":"First Steps","title":"First Steps","text":"S = randSeisData(4)\nn = 3\nappend!(S, SeisData(n))","category":"page"},{"location":"Intro/first_steps/","page":"First Steps","title":"First Steps","text":"This initializes an empty n-channel SeisData structure and appends it to the end of S, similar to appending one array to another. S will have 7 channels, but the last three are empty.","category":"page"},{"location":"Intro/first_steps/","page":"First Steps","title":"First Steps","text":"The addition operator, +, calls push! and add!, with one key difference: to ensure reflexivity (i.e., S1 + S2 == S2 + S1), the + operator sorts the output (command sort!) and prunes empty channels (command prune!). Thus,","category":"page"},{"location":"Intro/first_steps/","page":"First Steps","title":"First Steps","text":"S = SeisData(2)\nS1 = randSeisData(3)\nS += S1","category":"page"},{"location":"Intro/first_steps/","page":"First Steps","title":"First Steps","text":"outputs only the three channels of random data initialized in the second line of the code block; in addition, they're sorted by ID, so it's likely that S != S1.","category":"page"},{"location":"Intro/first_steps/#Search,-Sort,-and-Prune","page":"First Steps","title":"Search, Sort, and Prune","text":"","category":"section"},{"location":"Intro/first_steps/","page":"First Steps","title":"First Steps","text":"The easiest way to find channels of interest in a data structure is to use findid or findchan. findid(id S) returns the numeric index i of the first channel in S where Sidi == id. findchan(cha S) returns an array of numeric indices in S to all channels whose IDs satisfy occursin(cha Sidi).","category":"page"},{"location":"Intro/first_steps/","page":"First Steps","title":"First Steps","text":"For example:","category":"page"},{"location":"Intro/first_steps/","page":"First Steps","title":"First Steps","text":"L = GeoLoc(lat=46.1967, lon=-122.1875, el=1440.0, az=0.0, inc=0.0)\nS = SeisData(randSeisData(5), SeisChannel(id=\"YY.STA1..EHZ\"),\n      SeisChannel(id=\"UW.SEP..EHZ\", name=\"Darth Exploded\", loc=L))\nfindid(\"UW.SEP..EHZ\", S)    # 7\nfindchan(\"EHZ\", S)          # [6, 7], maybe others (depending on randSeisData)","category":"page"},{"location":"Intro/first_steps/","page":"First Steps","title":"First Steps","text":"You can sort channels in a structure by channel ID with the sort! command.","category":"page"},{"location":"Intro/first_steps/","page":"First Steps","title":"First Steps","text":"Several functions exist to prune empty and unwanted channels from SeisData structures. Revisiting the previous code block, for example, try these:","category":"page"},{"location":"Intro/first_steps/","page":"First Steps","title":"First Steps","text":"deleteat!(S, 1:2)   # Delete first two channels of S\nS -= 3              # Delete third channel of S\n\n# Extract S[1] as a SeisChannel, removing it from S\nC = pull(S, 1)\n\n# Delete channels containing \".SEP.\"\ndelete!(S, \".SEP.\", exact=false)\n\n# Delete all channels whose S.x is empty\nprune!(S)\nS","category":"page"},{"location":"Intro/first_steps/","page":"First Steps","title":"First Steps","text":"S should have one channel left.","category":"page"},{"location":"Intro/first_steps/","page":"First Steps","title":"First Steps","text":"In the delete! command, specifying exact=false means that any channel whose ID partly matches the string \".SEP.\" gets deleted; by default, delete(S str) only matches channels where str is the exact ID. This is an efficient way to remove unresponsive subnets and unwanted channel types, but beware of accidental over-matching.","category":"page"},{"location":"Intro/first_steps/#Next-Steps","page":"First Steps","title":"Next Steps","text":"","category":"section"},{"location":"Intro/first_steps/","page":"First Steps","title":"First Steps","text":"Because tracking arbitrary operations can be difficult, several functions have been written to keep track of data and operations in a semi-automated way. See the next section, working with data, for detailed discussion of managing data from the Julia command prompt.","category":"page"},{"location":"WritingFiles/writing/#write_support","page":"Write Support","title":"Write Suppport","text":"","category":"section"},{"location":"WritingFiles/writing/","page":"Write Support","title":"Write Support","text":"The table below sumamrizes the current write options for SeisBase. Each function is described in detail in this chapter.","category":"page"},{"location":"WritingFiles/writing/","page":"Write Support","title":"Write Support","text":"Structure/Description Output Format Function\nGphysChannel ASDF write_hdf5\nGphysChannel SAC timeseries writesac\nGphysChannel channel metadata StationXML write_sxml\nGphysChannel instrument response SAC polezero writesacpz\nGphysData ASDF write_hdf5\nGphysData SAC timeseries writesac\nGphysData channel metadata StationXML write_sxml\nGphysData instrument response SAC polezero writesacpz\nSeisEvent ASDF write_hdf5\nSeisEvent header and source info ASDF QuakeML asdf_wqml\nSeisEvent header and source info QuakeML write_qml\nSeisEvent trace data only SAC timeseries writesac\nArray{SeisEvent, 1} ASDF QuakeML asdf_wqml\nArray{SeisHdr, 1} QuakeML write_qml\nArray{SeisHdr, 1}, Array{SeisSrc, 1} ASDF QuakeML asdf_wqml\nArray{SeisHdr, 1}, Array{SeisSrc, 1} QuakeML write_qml\nSeisHdr QuakeML write_qml\nSeisHdr, SeisSrc ASDF QuakeML asdf_wqml\nSeisHdr, SeisSrc QuakeML wqml\nany SeisBase structure SeisBase file wseis\nprimitive data type or array ASDF AuxiliaryData asdf_waux","category":"page"},{"location":"WritingFiles/writing/","page":"Write Support","title":"Write Support","text":"Methods for SeisEvent, SeisHdr, or SeisSrc are part of submodule SeisBase.Quake. asdf_waux and asdf_wqml are part of SeisBase.SeisHDF.","category":"page"},{"location":"WritingFiles/writing/#Write-Functions","page":"Write Support","title":"Write Functions","text":"","category":"section"},{"location":"WritingFiles/writing/","page":"Write Support","title":"Write Support","text":"Functions are organized by file format.","category":"page"},{"location":"WritingFiles/writing/#HDF5/ASDF","page":"Write Support","title":"HDF5/ASDF","text":"","category":"section"},{"location":"WritingFiles/writing/","page":"Write Support","title":"Write Support","text":"write_hdf5","category":"page"},{"location":"WritingFiles/writing/#SeisBase.SeisHDF.write_hdf5","page":"Write Support","title":"SeisBase.SeisHDF.write_hdf5","text":"write_hdf5( hdf_out::String, S::GphysData[, KWs] )\n\nWrite data to file hdf_out from structure S in a seismic HDF5 format.\n\nwrite_hdf5( hdf_out::String, W::SeisEvent[, KWs] )\n\nWrite data to file hdf_out from structure W in a seismic HDF5 format. If the format doesn't record event header and source info, only W.data is stored.\n\nKeywords\n\nGphysData\n\nKW Type Default Meaning\nadd Bool false Add new traces to file as needed?\nchans ChanSpec 1:S.n Channels to write to file\nlen Period Day(1) Length of new traces added to file\novr Bool false Overwrite data in existing traces?\ntag String \"\" Tag for trace names in ASDF volumes\nv Integer 0 verbosity\n\nSeisEvent\n\nKW Type Default Meaning\nchans ChanSpec 1:S.data.n Channels to write to file\ntag String \"\" Tag for trace names in ASDF volumes\nv Integer 0 verbosity\n\nWrite Methods\n\nAdd (add = true)\n\nThis KW determines the start and end times of all data in chans, and initializes new traces (filled with NaNs) of length = len.\n\nASDF behavior\n\nMode add=true follows these steps in this order:\n\nDetermine times of all data in S[chans] and all traces in \"Waveforms/\".\nIf data lie outside existing trace bounds, new traces are initialized.\nFor each segment in S[chans]:\n\nMerge the header data in S[chans] into the relevant station XML.\nOverwrite part of the relevant trace in Waveforms/.\n\nThus, unless len exactly matches the time boundaries of each segment in S, the traces created will be intentionally larger.\n\nOverwrite (ovr = true)\n\nIf ovr=true is specified, but add=false, write_hdf5 only overwrites existing data in hdf_out.\n\nNo new trace data objects are created in hdf_out.\nNo new file is created. If hdf_out doesn't exist, nothing happens.\nIf no traces in hdf_out overlap segments in S, hdf_out isn't modified.\nIn ASDF format, station XML is merged in channels that are partly overwritten.\n\nwarning: Warning\nadd=true/ovr=true changes :t on file to begin at an exact sample time.\n\nSee also: read_hdf5\n\n\n\n\n\n","category":"function"},{"location":"WritingFiles/writing/#write_qml","page":"Write Support","title":"QuakeML","text":"","category":"section"},{"location":"WritingFiles/writing/","page":"Write Support","title":"Write Support","text":"SeisBase.Quake.write_qml","category":"page"},{"location":"WritingFiles/writing/#SeisBase.Quake.write_qml","page":"Write Support","title":"SeisBase.Quake.write_qml","text":"write_qml(fname, Ev::SeisEvent; v::Integer=0)\n\nWrite event metadata from SeisEvent Ev to file fname.\n\nwrite_qml(fname, SHDR::SeisHdr; v::Integer=0)\nwrite_qml(fname, SHDR::Array{SeisHdr,1}; v::Integer=0)\n\nWrite QML to file fname from SHDR.\n\nIf fname exists, and is QuakeML, SeisBase appends the existing XML. If the file exists, but is NOT QuakeML, an error is thrown; the file isn't overwritten.\n\nwrite_qml(fname, SHDR::SeisHdr, SSRC::SeisSrc; v::Integer=0)\nwrite_qml(fname, SHDR::Array{SeisHdr,1}, SSRC::Array{SeisSrc,1}; v::Integer=0)\n\nWrite QML to file fname from SHDR and SSRC.\n\nwarning: Warning\nTo write data from R ∈ SSRC, it must be true that R.eid == H.id for some H ∈ SHDR.\n\n\n\n\n\n","category":"function"},{"location":"WritingFiles/writing/#SAC","page":"Write Support","title":"SAC","text":"","category":"section"},{"location":"WritingFiles/writing/","page":"Write Support","title":"Write Support","text":"writesac\nwritesacpz","category":"page"},{"location":"WritingFiles/writing/#SeisBase.writesac","page":"Write Support","title":"SeisBase.writesac","text":"writesac(W::SeisEvent[, v=0])\n\nWrite all data in SeisEvent structure W to auto-generated SAC files. Event header information is written from W.hdr; W.source is not used as there is no standard header position for event source information.\n\n\n\n\n\nwritesac(S::Union{GphysData,GphysChannel}[, chans, nvhdr=6, fname=\"\", v=0])\n\nWrite all data in SeisData structure S to auto-generated SAC files.\n\nWith any GphysChannel subtype, specifying fname = FF sets the filename to FF.\n\nKeywords:\n\nchans=\"CC\" writes data from ChanSpec CC (GphysData only)\nfname=\"FF\" uses filename FF (GphysChannel only)\nnvhdr is SAC NVHDR, the file header version (6 or 7). Default is 6.\nv is verbosity.\n\n\n\n\n\n","category":"function"},{"location":"WritingFiles/writing/#SeisBase.writesacpz","page":"Write Support","title":"SeisBase.writesacpz","text":"writesacpz(pzfile::String, S::GphysData[, chans::ChanSpec=CC])\n\nWrite fields from SeisBase struct S into sacpz file pzfile. Uses information from fields :fs, :gain, :loc, :misc, :name, :resp, :units. Specify chans=CC to only write channels CC.\n\n\n\n\n\n","category":"function"},{"location":"WritingFiles/writing/#SeisBase-Native","page":"Write Support","title":"SeisBase Native","text":"","category":"section"},{"location":"WritingFiles/writing/","page":"Write Support","title":"Write Support","text":"wseis","category":"page"},{"location":"WritingFiles/writing/#SeisBase.wseis","page":"Write Support","title":"SeisBase.wseis","text":"wseis(fname, S)\n\nWrite SeisBase objects S to file. S can be a single object, multiple comma-delineated objects, or an array of objects.\n\n\n\n\n\n","category":"function"},{"location":"WritingFiles/writing/#Station-XML","page":"Write Support","title":"Station XML","text":"","category":"section"},{"location":"WritingFiles/writing/","page":"Write Support","title":"Write Support","text":"write_sxml","category":"page"},{"location":"WritingFiles/writing/#SeisBase.write_sxml","page":"Write Support","title":"SeisBase.write_sxml","text":"write_sxml(fname::String, S::GphysData[, chans=Cha])\nwrite_sxml(fname::String, C::GphysChannel)\n\nWrite station XML from the fields of S or C to file fname.\n\nUse keyword chans=Cha to restrict station XML write to Cha. This keyword can accept an Integer, UnitRange, or Array{Int64,1} as its argument.\n\n\n\n\n\n","category":"function"},{"location":"ReadingFiles/hdf5/#HDF5-Files","page":"HDF5 Files","title":"HDF5 Files","text":"","category":"section"},{"location":"ReadingFiles/hdf5/","page":"HDF5 Files","title":"HDF5 Files","text":"Of the increasingly popular HDF5-based formats for geophysical data, only ASDF is supported at present. Support for other (sub)formats is planned.","category":"page"},{"location":"ReadingFiles/hdf5/","page":"HDF5 Files","title":"HDF5 Files","text":"S = read_hdf5(fname::String, s::TimeSpec, t::TimeSpec, [, KWs])\nread_hdf5!(S::GphysData, fname::String, s::TimeSpec, t::TimeSpec, [, KWs])","category":"page"},{"location":"ReadingFiles/hdf5/","page":"HDF5 Files","title":"HDF5 Files","text":"Read data in seismic HDF5 file format from file fname into S. KWs Keyword arguments; see also Shared Keywords or type ?SeisBase.KW.","category":"page"},{"location":"ReadingFiles/hdf5/","page":"HDF5 Files","title":"HDF5 Files","text":"This has one fundamental design difference from read_data: HDF5 archives are assumed to be large files with data from multiple channels; they are scanned selectively for data of interest to read, rather than read into memory in their entirety.","category":"page"},{"location":"ReadingFiles/hdf5/#Supported-Keywords","page":"HDF5 Files","title":"Supported Keywords","text":"","category":"section"},{"location":"ReadingFiles/hdf5/","page":"HDF5 Files","title":"HDF5 Files","text":"KW Type Default Meaning\nid String \\\"...*\\\" id pattern, formated nn.sss.ll.ccc\n   (net.sta.loc.cha); FDSN-style wildcards [1]\nmsr Bool true read full (MultiStageResp) instrument resp?\nv Integer 0 verbosity","category":"page"},{"location":"ReadingFiles/hdf5/","page":"HDF5 Files","title":"HDF5 Files","text":"A question mark ('?') is a wildcard for a single character (exactly one); an asterisk ('*') is a wildcard for zero or more characters.","category":"page"},{"location":"ReadingFiles/hdf5/","page":"HDF5 Files","title":"HDF5 Files","text":"Writing to HDF5 volumes is supported through write_hdf5, described in Writing to File.","category":"page"},{"location":"#SeisBase","page":"Home","title":"SeisBase","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SeisBase is a collection of utilities for reading and downloading geophysical timeseries data.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"Intro/intro.md\",\n    \"Intro/first_steps.md\",\n    \"Intro/working_with_data.md\",\n    \"Intro/getting_help.md\",\n\n    \"ReadingFiles/timeseries.md\",\n    \"ReadingFiles/metadata.md\",\n    \"ReadingFiles/hdf5.md\",\n    \"ReadingFiles/xml.md\",\n\n    \"Downloading/web_services.md\",\n    \"Downloading/seedlink.md\",\n\n    \"WritingFiles/writing.md\",\n\n    \"Processing/data_processing.md\",\n\n    \"Submodules/submodules.md\",\n    \"Submodules/nodal.md\",\n    \"Submodules/quake.md\",\n    \"Submodules/seishdf.md\",\n\n    \"Appendices/appendix.md\",\n]\nDepth = 3","category":"page"}]
}
