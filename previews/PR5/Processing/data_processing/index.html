<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Data Processing · SeisBase.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SeisBase.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Intro</span><ul><li><a class="tocitem" href="../../Intro/intro/">Introduction</a></li><li><a class="tocitem" href="../../Intro/first_steps/">First Steps</a></li><li><a class="tocitem" href="../../Intro/working_with_data/">Working with data</a></li><li><a class="tocitem" href="../../Intro/getting_help/">Getting Help</a></li></ul></li><li><span class="tocitem">Reading files</span><ul><li><a class="tocitem" href="../../ReadingFiles/timeseries/">Time-Series Files</a></li><li><a class="tocitem" href="../../ReadingFiles/metadata/">Metadata Files</a></li><li><a class="tocitem" href="../../ReadingFiles/hdf5/">HDF5 Files</a></li><li><a class="tocitem" href="../../ReadingFiles/xml/">XML Meta-Data</a></li></ul></li><li><span class="tocitem">Downloading</span><ul><li><a class="tocitem" href="../../Downloading/web_services/">Web Services</a></li><li><a class="tocitem" href="../../Downloading/seedlink/">SeedLink</a></li></ul></li><li><span class="tocitem">Writing files</span><ul><li><a class="tocitem" href="../../WritingFiles/writing/">Write Support</a></li></ul></li><li><span class="tocitem">Processing</span><ul><li class="is-active"><a class="tocitem" href>Data Processing</a><ul class="internal"><li><a class="tocitem" href="#Basic-Operations"><span>Basic Operations</span></a></li><li><a class="tocitem" href="#Customizable-Operations"><span>Customizable Operations</span></a></li></ul></li></ul></li><li><span class="tocitem">Submodules</span><ul><li><a class="tocitem" href="../../Submodules/submodules/">Submodules</a></li><li><a class="tocitem" href="../../Submodules/nodal/">Nodal</a></li><li><a class="tocitem" href="../../Submodules/quake/">Quake</a></li><li><a class="tocitem" href="../../Submodules/seishdf/">SeisHDF</a></li></ul></li><li><span class="tocitem">Appendices</span><ul><li><a class="tocitem" href="../../Appendices/appendix/">Appendices</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Processing</a></li><li class="is-active"><a href>Data Processing</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Data Processing</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSeismo/SeisBase.jl/blob/main/docs/src/Processing/data_processing.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Data-Processing"><a class="docs-heading-anchor" href="#Data-Processing">Data Processing</a><a id="Data-Processing-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Processing" title="Permalink"></a></h1><p>Supported processing operations are described below.</p><p>In most cases, a &quot;safe&quot; version of each function can be invoked to create a new object with the processed output.</p><p>Any function that can logically operate on a single-channel object will do so. Any function that operates on a SeisData object can be applied to the :data field of a SeisEvent object.</p><h2 id="Basic-Operations"><a class="docs-heading-anchor" href="#Basic-Operations">Basic Operations</a><a id="Basic-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Operations" title="Permalink"></a></h2><p>These functions have no keywords that fundamentally change their behavior.</p><article class="docstring"><header><a class="docstring-binding" id="SeisBase.demean!" href="#SeisBase.demean!"><code>SeisBase.demean!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">demean!(S::SeisData[; chans=CC, irr=false])</code></pre><p>Remove the mean from all channels <code>i</code> with <code>S.fs[i] &gt; 0.0</code>. Specify <code>irr=true</code> to also remove the mean from irregularly sampled channels (with S.fs[i] == 0.0). Specifying a channel list with <code>chans=CC</code> restricts processing to channels CC.</p><pre><code class="nohighlight hljs">demean!(C::SeisChannel)</code></pre><p>Remove the mean from data in <code>C</code>.</p><p>Ignores NaNs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSeismo/SeisBase.jl/blob/4c23555f9673b1229587ad75486db9524f99a80e/src/Processing/detrend.jl#L3-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeisBase.detrend!" href="#SeisBase.detrend!"><code>SeisBase.detrend!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">detrend!(S::SeisData[; chans=CC, n=1]))</code></pre><p>Remove the linear trend from channels <code>CC</code>. Ignores NaNs.</p><p>To remove a higher-order polynomial fit than a linear trend, choose <code>n</code> &gt;1.</p><pre><code class="nohighlight hljs">detrend!(C::SeisChanel[; n=1]))</code></pre><p>Remove the linear trend from data in <code>C</code>. Ignores NaNs.</p><p>To remove a higher-order polynomial fit than a linear trend, choose n&gt;1.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>detrend! does <em>not</em> check for data gaps; if this is problematic, call ungap!(S, m=true) first!</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSeismo/SeisBase.jl/blob/4c23555f9673b1229587ad75486db9524f99a80e/src/Processing/detrend.jl#L114-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeisBase.env!" href="#SeisBase.env!"><code>SeisBase.env!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">env!(S::GphysData[, chans=CC, v=V])
env(S::GphysData)</code></pre><p>Compute the envelope of channel data in S. Only affects regularly-sampled channels.</p><p>In-place conversion of S.x[i] ==&gt; Env(S.x[i]) (≡ |H(S.x[i])|, where H denotes the Hilbert transform).</p><p><strong>Keywords</strong></p><ul><li>chans=CC: only process channels in CC (with fs &gt; 0.0).</li><li>v=V: verbosity.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSeismo/SeisBase.jl/blob/4c23555f9673b1229587ad75486db9524f99a80e/src/Processing/env.jl#L3-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeisBase.nanfill!" href="#SeisBase.nanfill!"><code>SeisBase.nanfill!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nanfill!(S::SeisData)
nanfill!(C::SeisChannel)</code></pre><p>For each channel <code>i</code> in <code>S</code>, replace all NaNs in <code>S.x[i]</code> with the mean of non-NaN values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSeismo/SeisBase.jl/blob/4c23555f9673b1229587ad75486db9524f99a80e/src/Processing/nanfill.jl#L16-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeisBase.resample!" href="#SeisBase.resample!"><code>SeisBase.resample!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">resample!(S::SeisData [, chans=CC, fs=FS])
resample(S::SeisData [, chans=CC, fs=FS])</code></pre><p>Resample data in S to <code>FS</code>. If keyword <code>fs</code> is not specified, data are resampled to the lowest non-zero value in <code>S.fs[CC]</code>.Note that a poor choice of <code>FS</code> can lead to upsampling and other undesirable behavior.</p><p>Use keyword <code>chans=CC</code> to only resample channel numbers <code>CC</code>. By default, all channels <code>i</code> with <code>S.fs[i] &gt; 0.0</code> are resampled.</p><pre><code class="nohighlight hljs">resample!(C::SeisChannel, fs::Float64)
resample(C::SeisChannel, fs::Float64)</code></pre><p>Resample <code>C.x</code> to <code>fs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSeismo/SeisBase.jl/blob/4c23555f9673b1229587ad75486db9524f99a80e/src/Processing/resample.jl#L44-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeisBase.unscale!" href="#SeisBase.unscale!"><code>SeisBase.unscale!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unscale!(S::GphysData[, chans=CC, irr=false])</code></pre><p>Divide out the gains of all channels <code>i</code> where <code>S.fs[i] &gt; 0.0</code>. Specify <code>irr=true</code> to also remove the gains of irregularly-sampled channels. Use keyword <code>chans=CC</code> to only resample channel numbers <code>CC</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSeismo/SeisBase.jl/blob/4c23555f9673b1229587ad75486db9524f99a80e/src/Processing/unscale.jl#L3-L10">source</a></section></article><h2 id="Customizable-Operations"><a class="docs-heading-anchor" href="#Customizable-Operations">Customizable Operations</a><a id="Customizable-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Customizable-Operations" title="Permalink"></a></h2><h3 id="Convert-Seismograms"><a class="docs-heading-anchor" href="#Convert-Seismograms">Convert Seismograms</a><a id="Convert-Seismograms-1"></a><a class="docs-heading-anchor-permalink" href="#Convert-Seismograms" title="Permalink"></a></h3><p>Seismograms can be converted to or from displacement, velocity, or acceleration using convert_seis:</p><article class="docstring"><header><a class="docstring-binding" id="SeisBase.convert_seis!" href="#SeisBase.convert_seis!"><code>SeisBase.convert_seis!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">convert_seis!(S[, chans=CC, units_out=UU, v=V])
convert_seis(S, chans=CC, units_out=UU, v=V])
convert_seis!(C[, units_out=UU, v=V])
convert_seis(CC, units_out=UU, v=V)</code></pre><p>Convert all seismic data channels in <code>S</code> to velocity seismograms, differentiating or integrating as needed.</p><p><strong>Keywords</strong></p><ul><li><code>units_out=UU</code> specifies output units.<ul><li>Default: &quot;m/s&quot;.</li><li>Allowed: &quot;m&quot;, &quot;m/s&quot;, or &quot;m/s2&quot;. (SeisBase uses Unicode (UTF-8) UCUM units.)</li></ul></li><li><code>v=V</code> sets verbosity.</li><li><code>chans=CC</code> restricts seismogram conversion to seismic data channels within <code>CC</code>.<ul><li><code>chans</code> can be an Integer, UnitRange, or Array{Int64,1}.</li><li>By default, all seismic data channels in <code>S</code> are converted (if needed).</li><li>This does not allow <code>convert_seis!</code> to work on non-seismic data.</li></ul></li></ul><div class="admonition is-warning"><header class="admonition-header">Seismogram length at `Float32` precision</header><div class="admonition-body"><p><code>convert_seis!</code> becomes less reversible as seismograms lengthen, particularly at <code>Float32</code> precision,  due to <a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic#Accuracy_problems">loss of significance</a>. At single (<code>Float32</code>) precision, seismograms with <code>N ~ 10^6</code> samples are reconstructable after one conversion  (e.g. <code>&quot;m&quot; ==&gt; &quot;m/s&quot;</code> can be reversed, with output approximately equal to the original data). After multiple  conversions (i.e., <code>&quot;m&quot; ==&gt; &quot;m/s²&quot;</code> or <code>&quot;m/s²&quot; ==&gt; &quot;m&quot;</code>), <code>Float32</code> data cannot be perfectly reconstructed in this way,  though reconstruction errors are typically small.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Rectangular Integration</header><div class="admonition-body"><p>Integration is always rectangular; irregularly-spaced seismic data are not processed by convert_seis. Summation  uses an in-place variant of <a href="https://github.com/JuliaMath/KahanSummation.jl">Kahan-Babuška-Neumaier summation</a></p></div></div><p><strong>References</strong></p><ol><li>Neumaier, A. (1974). &quot;Rundungsfehleranalyse einiger Verfahren zur Summation endlicher Summen&quot; [Rounding Error Analysis of Some Methods for Summing Finite Sums]. Zeitschrift für Angewandte Mathematik und Mechanik (in German). 54 (1): 39-51. doi:10.1002/zamm.19740540106.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSeismo/SeisBase.jl/blob/4c23555f9673b1229587ad75486db9524f99a80e/src/Processing/convert_seis.jl#L3-L36">source</a></section></article><h3 id="Fill-Gaps"><a class="docs-heading-anchor" href="#Fill-Gaps">Fill Gaps</a><a id="Fill-Gaps-1"></a><a class="docs-heading-anchor-permalink" href="#Fill-Gaps" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SeisBase.ungap!" href="#SeisBase.ungap!"><code>SeisBase.ungap!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ungap!(S[, chans=CC, m=true, tap=false])
ungap(S[, chans=CC, m=true, tap=false])</code></pre><p>Fill time gaps in each channel of S with the mean of the channel data.</p><pre><code class="nohighlight hljs">ungap!(C[, m=true, tap=false])
ungap(C[, m=true, tap=false])</code></pre><p>As above for GphysChannel object C.</p><p><strong>Keywords</strong></p><ul><li><code>chans=CC</code>: only ungap channels <code>CC</code>.</li><li><code>m=false</code>: this flag fills gaps with NaNs instead of the mean.</li><li><code>tap=true</code>: taper data before filling gaps.</li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>If channel segments aren&#39;t in chronological order, call <code>merge</code> before using <code>ungap</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSeismo/SeisBase.jl/blob/4c23555f9673b1229587ad75486db9524f99a80e/src/Processing/2_ungap.jl#L3-L22">source</a></section></article><h3 id="Merge"><a class="docs-heading-anchor" href="#Merge">Merge</a><a id="Merge-1"></a><a class="docs-heading-anchor-permalink" href="#Merge" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Base.merge!" href="#Base.merge!"><code>Base.merge!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">merge!(S::SeisData, U::SeisData[, prune_only=true])</code></pre><p>Merge channels of two SeisData structures.</p><p>Merge two GphysData structures. For timeseries data, a single-pass merge-and-prune operation is applied to value pairs whose sample times are separated by less than half the sampling interval.</p><pre><code class="nohighlight hljs">merge!(S::SeisData[, prune_only=true])</code></pre><p>&quot;Flatten&quot; a SeisData structure by merging channels with identical properties.</p><p>If <code>prune_only=true</code>, the only action taken is deletion of empty and duplicate channels; <code>merge!(S, U, prune_only=true)</code> is identical to an in-place <code>S+U</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSeismo/SeisBase.jl/blob/4c23555f9673b1229587ad75486db9524f99a80e/src/Processing/Merge/1_merge.jl#L1-L16">source</a></section></article><h4 id="Merge-Behavior"><a class="docs-heading-anchor" href="#Merge-Behavior">Merge Behavior</a><a id="Merge-Behavior-1"></a><a class="docs-heading-anchor-permalink" href="#Merge-Behavior" title="Permalink"></a></h4><p><strong>Which channels merge?</strong></p><ul><li>Channels merge if they have identical values for <span>$:id$</span>, <span>$:fs$</span>, <span>$:loc$</span>, <span>$:resp$</span>, and <span>$:units$</span>.</li><li>An unset <span>$:loc$</span>, <span>$:resp$</span>, or <span>$:units$</span> field matches any set value in the corresponding field of another channel.</li></ul><p><strong>What happens to merged fields?</strong></p><ul><li>The essential properties above are preserved.</li><li>Other fields are combined.</li><li>Merged channels with different <code>:name</code> values use the name of the channel with the latest data before the merge; other names are logged to <code>:notes</code>.</li></ul><p><strong>What does <span>$merge!$</span> resolve?</strong></p><table><tr><th style="text-align: right">Issue</th><th style="text-align: right">Resolution</th></tr><tr><td style="text-align: right">Empty channels</td><td style="text-align: right">Delete</td></tr><tr><td style="text-align: right">Duplicated channels</td><td style="text-align: right">Delete duplicate channels</td></tr><tr><td style="text-align: right">Duplicated windows in channel(s)</td><td style="text-align: right">Delete duplicate windows</td></tr><tr><td style="text-align: right">Multiple channels, same properties [<code>1</code>]</td><td style="text-align: right">Merge to a single channel</td></tr><tr><td style="text-align: right">Channel with out-of-order time windows</td><td style="text-align: right">Sort in chronological order</td></tr><tr><td style="text-align: right">Overlapping windows, identical data, time-aligned</td><td style="text-align: right">Windows merged</td></tr><tr><td style="text-align: right">Overlapping windows, identical data, small time offset [<code>2</code>]</td><td style="text-align: right">Time offset corrected, windows merged</td></tr><tr><td style="text-align: right">Overlapping windows, non-identical data</td><td style="text-align: right">Samples averaged, windows merged</td></tr></table><ul><li>[<code>1</code>]: &quot;Properties&quot; here are <span>$:id$</span>, <span>$:fs$</span>, <span>$:loc$</span>, <span>$:resp$</span>, and <span>$:units$</span>.</li><li>[<code>2</code>]: Data offset &gt;4 sample intervals are treated as overlapping and non-identical.</li></ul><p><strong>When SeisBase Won&#39;t Merge</strong> SeisBase does <strong>not</strong> combine data channels if <strong>any</strong> of the five fields above are non-empty and different. For example, if a GphysData object S contains two channels, each with id &quot;XX.FOO..BHZ&quot;, but one has fs=100 Hz and the other fs=50 Hz, <strong>merge!</strong> does nothing.</p><p>It&#39;s best to merge only unprocessed data. Data segments that were processed independently (e.g. detrended) will be averaged pointwise when merged, which can easily leave data in an unusuable state.</p><article class="docstring"><header><a class="docstring-binding" id="SeisBase.mseis!" href="#SeisBase.mseis!"><code>SeisBase.mseis!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mseis!(S::SeisData, U...)</code></pre><p>Merge multiple SeisData structures at once. The first argument (merge target) must be a SeisData structure. Subsequent structures can be any type T &lt;: Union{GphysData, GphysChannel, SeisEvent}.</p><pre><code class="nohighlight hljs">mseis!(C::GphysChannel, U...)</code></pre><p>Merge all channels in U that match channel C into object C. To be merged, a channel must match on fields <code>:id</code>, <code>:fs</code>, <code>:loc</code>, <code>:resp</code>, <code>:units</code>.</p><p>See also: <code>merge!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSeismo/SeisBase.jl/blob/4c23555f9673b1229587ad75486db9524f99a80e/src/Last/splat.jl#L24-L36">source</a></section></article><h3 id="Seismic-Instrument-Response"><a class="docs-heading-anchor" href="#Seismic-Instrument-Response">Seismic Instrument Response</a><a id="Seismic-Instrument-Response-1"></a><a class="docs-heading-anchor-permalink" href="#Seismic-Instrument-Response" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SeisBase.translate_resp!" href="#SeisBase.translate_resp!"><code>SeisBase.translate_resp!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">translate_resp!(S, resp_new[, chans=CC, wl=γ])
translate_resp(S, resp_new[, chans=CC, wl=γ])</code></pre><p>Translate the instrument response of seismic data channels <code>CC</code> in <code>S</code> to <code>resp_new</code>. Replaces field <code>:resp</code> with <code>resp_new</code> for all affected channels.</p><pre><code class="nohighlight hljs">remove_resp!(S, chans=CC, wl=γ])
remove_resp(S, chans=CC, wl=γ])</code></pre><p>Remove (flatten to DC) the instrument response of seismic data channels <code>cha</code> in <code>S</code>. Replaces field <code>:resp</code> with the appropriate (all-pass) response.</p><pre><code class="nohighlight hljs">translate_resp!(Ch, resp_new[, wl=γ])
translate_resp(Ch, resp_new[, wl=γ])</code></pre><p>Translate the instrument response of seismic data in SeisChannel object <code>Ch</code> to <code>resp_new</code>. Replaces field <code>:resp</code> with <code>resp_new</code>.</p><pre><code class="nohighlight hljs">remove_resp!(Ch[, chans=CC, wl=γ])
remove_resp(Ch[, chans=CC, wl=γ])</code></pre><p>Remove (flatten to DC) the instrument response of seismic data in <code>Ch</code>. Replaces field <code>:resp</code> with the appropriate (all-pass) response.</p><p><strong>Keywords</strong></p><ul><li><strong>chans=CC</strong> restricts response translation to channel(s) <code>CC</code>. By default, all seismic data channels have responses translated to <code>resp_new</code>.</li><li><strong>wl=γ</strong> sets the waterlevel to γ (default: <code>γ</code> = eps(Float32) ≈ ~1f-7)</li></ul><p>The waterlevel is the minimum magnitude (absolute value) of the normalized old frequency response; in other words,  if the old frequency response has a maximum magnitude of 1.0, then no response coefficient can be lower than g.  This is useful to prevent &quot;divide by zero&quot; errors, but setting it too high will cause errors.</p><p><strong>Interaction with the :resp field</strong></p><p><code>translate_resp</code> and <code>remove_resp</code> only work on a channel <code>i</code> that satisfies <code>S.resp[i] &lt;: PZResp, PZResp64, MultiStageResp</code>. In the last case, <code>S.resp[i].stage[1]</code> must be a PZResp or PZResp64, only the first stage of the response is changed, and the stage gain is ignored; instead, the sensitivity <code>S.resp[i].stage[1].a0</code> is used.</p><p><strong>Poles and zeros should be rad/s</strong></p><p>Always check when loading from an unsupported data format. Responses read from station XML are corrected to rad/s automatically (most use rad/s); responses read from a SACPZ or SEED RESP file already use rad/s.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Response translation doesn&#39;t guarantee causality; if this is a problem, detrend and taper first!</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSeismo/SeisBase.jl/blob/4c23555f9673b1229587ad75486db9524f99a80e/src/Processing/Resp/translate_resp.jl#L5-L47">source</a></section></article><h4 id="Precision-and-Memory-Optimization"><a class="docs-heading-anchor" href="#Precision-and-Memory-Optimization">Precision and Memory Optimization</a><a id="Precision-and-Memory-Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Precision-and-Memory-Optimization" title="Permalink"></a></h4><p>To optimize speed and memory use, instrument response translation maps data to Complex{Float32} before translation; thus, with Float64 data, there can be minor rounding errors.</p><p>Instrument responses are also memory-intensive. The minimum memory consumption to translate the response of a gapless Float32 SeisChannel object is ~7x the size of the object itself.</p><p>More precisely, for an object <strong>S</strong> (of Type &lt;: GphysData or GphysChannel), translation requires memory ~ 2 kB + the greater of (7x the size of the longest Float32 segment, or 3.5x the size of the longest Float64 segment). Translation uses four vectors – three complex and one real – that are updated and dynamically resized as the algorithm loops over each segment:</p><ul><li>Old response container: Array{Complex{Float32,1}}(undef, Nx)</li><li>New response container: Array{Complex{Float32,1}}(undef, Nx)</li><li>Complex data container: Array{Complex{Float32,1}}(undef, Nx)</li><li>Real frequencies for FFT: Array{Float32,1}(undef, Nx)</li></ul><p>...where <strong>Nx</strong> is the number of samples in the longest segment in <strong>S</strong>.</p><h4 id="Causality"><a class="docs-heading-anchor" href="#Causality">Causality</a><a id="Causality-1"></a><a class="docs-heading-anchor-permalink" href="#Causality" title="Permalink"></a></h4><p>Response translation adds no additional processing to guarantee causality. At a minimum, most users will want to call <span>$detrend!$</span> and <span>$taper!$</span> before translating instrument responses.</p><h3 id="Synchronize"><a class="docs-heading-anchor" href="#Synchronize">Synchronize</a><a id="Synchronize-1"></a><a class="docs-heading-anchor-permalink" href="#Synchronize" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SeisBase.sync!" href="#SeisBase.sync!"><code>SeisBase.sync!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>sync!(S::GphysData)</p><p>Synchronize the start times of all data in S to begin at or after the last start time in S.</p><p>sync!(S[, s=TS, t=TT, pad=false, v=V])</p><p>Synchronize all data in S to start no earlier than <code>TS</code> and terminate no later than <code>TT</code>, with verbosity level <code>V</code>.</p><p>By default, a channel with mean <code>μᵢ = mean(S.x[i])</code> that begins after <code>TS</code> is prepended with <code>μᵢ</code> to begin exactly at <code>TS</code>; similarly, if keyword <code>t</code> is used, <code>μᵢ</code> is appended so that data ends at <code>TT</code>. If <code>pad=false</code>, channels that begin after <code>TS</code> or end before <code>TT</code> are not extended in either direction.</p><p>For regularly-sampled channels, gaps between the specified and true times are filled with the mean; this isn&#39;t possible with irregularly-sampled data.</p><p><strong>Specifying start time (<code>s=</code>)</strong></p><ul><li>s=&quot;last&quot;: (Default) sync to the last start time of any channel in <code>S</code>.</li><li>s=&quot;first&quot;: sync to the first start time of any channel in <code>S</code>.</li><li>A numeric value is treated as an epoch time (<code>?time</code> for details).</li><li>A DateTime is treated as a DateTime. (see Dates.DateTime for details.)</li><li>Any string other than &quot;last&quot; or &quot;first&quot; is parsed as a DateTime.</li></ul><p><strong>Specifying end time (<code>t=</code>)</strong></p><ul><li>t=&quot;none&quot;: (Default) end times are not synchronized.</li><li>t=&quot;last&quot;: synchronize all channels to end at the last end time in <code>S</code>.</li><li>t=&quot;first&quot; synchronize to the first end time in <code>S</code>.</li><li>numeric, datetime, and non-reserved strings are treated as for <code>s=</code>.</li></ul><p>See also: <code>TimeSpec</code>, <code>Dates.DateTime</code>, <code>parsetimewin</code></p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>sync!</code> calls <code>prune!</code>; empty channels will be deleted.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSeismo/SeisBase.jl/blob/4c23555f9673b1229587ad75486db9524f99a80e/src/Processing/sync.jl#L100-L137">source</a></section></article><h3 id="Taper"><a class="docs-heading-anchor" href="#Taper">Taper</a><a id="Taper-1"></a><a class="docs-heading-anchor-permalink" href="#Taper" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SeisBase.taper!" href="#SeisBase.taper!"><code>SeisBase.taper!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">taper!(C[; t_max::Real=10.0, α::Real=0.05, N_min::Int64=10])</code></pre><p>Cosine taper all time-series data in C. Tapers each segment of each channel that contains at least <code>N_min</code> total samples.</p><pre><code class="nohighlight hljs">taper!(S[; chans=CC, t_max::Real=10.0, α::Real=0.05, N_min::Int64=10])</code></pre><p>Cosine taper each segment of time-series data in GphysChannel object C that contains at least <code>N_min</code> total samples.</p><p>Does not modify irregularly-sampled data channels.</p><p>Keywords:</p><ul><li><code>chans</code>: Only taper the specified channels.</li><li><code>N_min</code>: Data segments with N &lt; N_min total samples are not tapered.</li><li><code>t_max</code>: Maximum taper edge in seconds.</li><li><code>α</code>: Taper edge area; as for a Tukey window, the first and last 100*α% of</li></ul><p>samples in each window are tapered, up to <code>t_max</code> seconds of data.</p><p>See also: <code>DSP.Windows.tukey</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSeismo/SeisBase.jl/blob/4c23555f9673b1229587ad75486db9524f99a80e/src/Processing/1_taper.jl#L30-L51">source</a></section></article><h3 id="Zero-Phase-Filter"><a class="docs-heading-anchor" href="#Zero-Phase-Filter">Zero-Phase Filter</a><a id="Zero-Phase-Filter-1"></a><a class="docs-heading-anchor-permalink" href="#Zero-Phase-Filter" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SeisBase.filtfilt!" href="#SeisBase.filtfilt!"><code>SeisBase.filtfilt!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>filtfilt!(S::GphysData[; KWs])</p><p>Apply zero-phase filter to S.x.</p><p>filtfilt!(C::GphysChannel[; KWs])</p><p>Apply zero-phase filter to C.x</p><p>Keywords control filtering behavior; specify as e.g. filtfilt!(S, fl=0.1, np=2, rt=&quot;Lowpass&quot;).</p><p><strong>Keywords</strong></p><table><tr><th style="text-align: left">Name</th><th style="text-align: left">Default</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left">chans</td><td style="text-align: left">(all)</td><td style="text-align: left">[1]</td><td style="text-align: left">channel numbers to filter</td></tr><tr><td style="text-align: left">fl</td><td style="text-align: left">1.0</td><td style="text-align: left">Float64</td><td style="text-align: left">lower corner frequency [Hz] [2]</td></tr><tr><td style="text-align: left">fh</td><td style="text-align: left">15.0</td><td style="text-align: left">Float64</td><td style="text-align: left">upper corner frequency [Hz] [2]</td></tr><tr><td style="text-align: left">np</td><td style="text-align: left">4</td><td style="text-align: left">Int64</td><td style="text-align: left">number of poles</td></tr><tr><td style="text-align: left">rp</td><td style="text-align: left">10</td><td style="text-align: left">Int64</td><td style="text-align: left">pass-band ripple (dB)</td></tr><tr><td style="text-align: left">rs</td><td style="text-align: left">30</td><td style="text-align: left">Int64</td><td style="text-align: left">stop-band ripple (dB)</td></tr><tr><td style="text-align: left">rt</td><td style="text-align: left">&quot;Bandpass&quot;</td><td style="text-align: left">String</td><td style="text-align: left">response type (type of filter)</td></tr><tr><td style="text-align: left">dm</td><td style="text-align: left">&quot;Butterworth&quot;</td><td style="text-align: left">String</td><td style="text-align: left">design mode (name of filter)</td></tr></table><ol><li>Allowed types are Integer, UnitRange, and Array{Int64, 1}.</li><li>By convention, the lower corner frequency (fl) is used in a Highpass</li></ol><p>filter, and fh is used in a Lowpass filter.</p><p>Default filtering KW values can be changed by adjusting the <a href="../../Appendices/appendix/#seisbase_std_keyword">Shared Keywords</a>,  e.g., <code>SeisBase.KW.Filt.np = 2</code> changes the default number of poles to 2.</p><p>See also: DSP.jl documentation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSeismo/SeisBase.jl/blob/4c23555f9673b1229587ad75486db9524f99a80e/src/Processing/filtfilt.jl#L142-L174">source</a></section></article><h3 id="Troubleshooting-NaNs-in-Output"><a class="docs-heading-anchor" href="#Troubleshooting-NaNs-in-Output">Troubleshooting NaNs in Output</a><a id="Troubleshooting-NaNs-in-Output-1"></a><a class="docs-heading-anchor-permalink" href="#Troubleshooting-NaNs-in-Output" title="Permalink"></a></h3><p>NaNs in the output of filtering operations (e.g., <em>filtfilt!</em>, <em>translate_resp!</em>) are nearly always the result of zeros in the denominator of the filter transfer function.</p><p>This is not a bug in SeisBase.</p><p>In particular, the increased speed of data processing at 32-bit precision comes with an increased risk of NaN output. The reason is that 32-bit machine epsilon (<span>$eps(Float32)$</span> in Julia) is <code>~1.0e-7</code>; by comparison, 64-bit machine epsilon is <code>~1.0e-16</code>.</p><p>Please check for common signal processing issues before reporting NaNs to SeisBase maintainers. For example:</p><h4 id="Filtering"><a class="docs-heading-anchor" href="#Filtering">Filtering</a><a id="Filtering-1"></a><a class="docs-heading-anchor-permalink" href="#Filtering" title="Permalink"></a></h4><ul><li>Is the pass band too narrow?</li><li>Is the lower corner frequency too close to DC?</li><li>Is the filter order (or number of poles) too high?</li></ul><h4 id="Instrument-Responses"><a class="docs-heading-anchor" href="#Instrument-Responses">Instrument Responses</a><a id="Instrument-Responses-1"></a><a class="docs-heading-anchor-permalink" href="#Instrument-Responses" title="Permalink"></a></h4><ul><li>Are the roll-off frequencies of the old and new responses too far apart?</li><li>Is the water level appropriate for the data scaling?</li></ul><h4 id="Suggested-References"><a class="docs-heading-anchor" href="#Suggested-References">Suggested References</a><a id="Suggested-References-1"></a><a class="docs-heading-anchor-permalink" href="#Suggested-References" title="Permalink"></a></h4><ol><li>Oppenheim, A.V., Buck, J.R. and Schafer, R.W., 2009. Discrete-time signal processing (3rd edition). Upper Saddle River, NJ, USA: Prentice Hall.</li><li>Orfanidis, S.J., 1995. Introduction to signal processing. Upper Saddle River, NJ, USA: Prentice Hall.</li></ol></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../WritingFiles/writing/">« Write Support</a><a class="docs-footer-nextpage" href="../../Submodules/submodules/">Submodules »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 6 June 2023 23:04">Tuesday 6 June 2023</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
